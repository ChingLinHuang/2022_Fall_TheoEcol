<<<<<<< HEAD
[["index.html", "Introduction to Theoretical Ecology Course information", " Introduction to Theoretical Ecology Instructor: Po-Ju Ke \\(~~~~~\\) Teaching Assistant: Sun Yi 2023 Fall at National Taiwan Univeristy Course information Description The development of theory plays an important role in advancing ecology as a scientific field. This three-unit course is for students at the graduate or advanced undergraduate level. The course will cover classic theoretical topics in population and community ecology, staring from single-species dynamics and gradually build up to multispecies models. Emphasis will be on theoretical concepts and corresponding mathematical approaches. This course is designed as a two-hour lecture (written on black board) followed by a one-hour complementary hands-on practice module. In the lecture, we will analyze dynamical models and discuss their theoretical implications. In the practice section, we will use a combination interactive applications and numerical simulations to gain more intuition of the dynamics and behavior of different models. Objective By the end of the course, students are expected to be familiar with the basic building blocks of ecological models, and would be able to formulate and analyze simple models of their own. The hands-on practice component should allow students to link their ecological intuition with the underlying mathematical model, helping them to better understand the primary literature of theoretical ecology. Requirement Students are only expected to have a basic understanding of Calculus (e.g., freshman introductory course) and Ecology. It’s OK if you’re not familiar with calculus as we will provide relevant material for you to review during the first week. Format Tuesday 6,7,8 (1:20 pm ~ 4:20 pm) at 共207 Grading The final grade consists of: Assignment problem sets (60%) Midterm exam (15%) Final exam (15%) Course participation (10%) Course materials We will use a combination of textbooks of theoretical ecology. Textbook chapters and additional reading materials (listed in the course outline) will be provided. (see Syllabus for more details). Below are the textbook references: A Primer of Ecology (4th edition). Nicholas Gotelli, 2008. An Illustrated Guide to Theoretical Ecology. Ted Case, 2000. A Biologist’s Guide to Mathematical Modeling in Ecology and Evolution. Sarah Otto &amp; Troy Day, 2011. Mathematical Ecology of Populations and Ecosystems. John Pastor, 2008. Nonlinear Dynamics and Choas. Steven Strogatz, 2000. Contacts Instructor: Po-Ju Ke Office: Life Science Building R635 Email: pojuke@ntu.edu.tw Office hours: by appointment Teaching assistant: Sun Yi Office: Life Science Building R635 Email: r11b44014@ntu.edu.tw Office hours: 14:00 ~ 15:00 on Thursday or by appointment "],["syllabus.html", "Syllabus", " Syllabus Date Lecture topic Lab Readings Week 1 9/5 Introduction: what is theoretical ecology? - Grainger et al. (2021) An empiricist’s guide to using ecological theroy. The American Naturalist, 199: 1-20 Week 2 9/12 Exponential population growth Solving exponential growth equation using “deSolve” &amp; Visualization Gotelli [Ch.1], Case[Ch.1] Week 3 9/19 Logistic population growth and stability analysis Shinny App for logistic population growth Gotelli [Ch.2], Case[Ch.5], Otto &amp; Day[Ch.5] Week 4 9/26 Harvesting and bifurcation Alternative stable state diagram Pastor [Ch. 7], Strogatz [Ch. 3] Week 5 10/3 Metapopulations and patch occupancy models Metapopulations and patch occupancy models Gotelli [Ch.4], Case[Ch.16] Week 6 10/10 No class (National holiday) - - Week 7 10/17 Age-structured population models Age-structured population model Gotelli [Ch.3], Case[Ch.3] Week 8 10/24 Lotka-Volterra model of competition: graphical analysis Lotka-Volterra competition model - Population dynamics Gotelli [Ch.5], Case[Ch.14] Week 9 10/31 Midterm exam - - Week 10 11/7 Lotka-Volterra model of competition: invasion analysis and linear stability analysis Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues Otto &amp; Day [Ch.8] Broekman et al. (2019) Signs of stabilization and stable coexistence. Ecology Letters, 22: 1957-1975 Week 11 11/14 Predator-prey interactions (I) Lotka-Volterra model of predator-prey interactions and time-scale separation Gotelli [Ch.6], Case[Ch.12, 13] Week 12 11/21 Predator-prey interactions (II) + Discussion on May (1972) Rosenzweig-MacArthur predator-prey model and May’s complexity-stability relationship Gotelli [Ch.6], Case[Ch.12, 13] May (1972). Will a large complex system be stable? Nature, 238: 413-414 Week 13 11/28 Mechanistic models for consumer-resource dynamics Parameter space for apparent competition model Tilman (1980) Resources: A graphical-mechanistic approach to competition and predation. The American Naturalist, 116: 162-193 Armstrong &amp; McGehee (1980) Competitive exclusion. The American Naturalist, 115: 151-170. Week 14 12/5 Multispecies models of predation: apparent competition Resource competition Holt (1977) Predation, apparent competition, and the structure of prey communities. Theoretical Population Biology, 12:197-229 Week 15 12/12 Research applcations: plant-soil feedback as an example - - Week 16 12/19 Final exam - - "],["week-2---exponential-population-growth.html", "Week 2 - Exponential population growth", " Week 2 - Exponential population growth In part 1, we will solve the differential equation for exponential population growth and visualize how the population sizes change over time. Part 1 - Numerical solution using the package “deSolve” Two main phases: Model specification: specify the structure of differential equation model Model application: set the time steps, initial population size and model parameters (e.g., intrinsic population growth rate r), and then solve the equation model p span#aaa:before { content: \"(1) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } p span#bbb:before { content: \"(2) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } d-article table.lightable-paper { margin-bottom: 0px; } Consider the model \\[ \\frac{dN}{dt} = rN \\] where \\(N\\) is population size and \\(r\\) is the intrinsic growth rate. ###### part 1 ###### # install.packages(&quot;deSolve&quot;) library(deSolve) ### (1) Model specification exponential_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N # exponential growth equation return(list(c(dN_dt))) # return the results }) } Set the time steps, initial population size and model parameters. ### (2) Model application times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r = 1.5) # intrinsic growth rate Solve the equation by ode() numerically. # run the ode solver pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # take a look at the results head(pop_size) ## time N ## [1,] 0.0 10.00000 ## [2,] 0.1 11.61834 ## [3,] 0.2 13.49860 ## [4,] 0.3 15.68313 ## [5,] 0.4 18.22120 ## [6,] 0.5 21.17002 Visualization plot(N ~ time, data = pop_size) plot(N ~ time, data = pop_size, log = &quot;y&quot;) Part 2 - Comparing different ode solvers In default of ode(), the equations are solved by LSODA method. We can change the method by modifying the argument method in ode(). ###### part 2 ###### # original setting times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r = 1.5) # intrinsic growth rate # default: LSODA pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # Euler&#39;s method pop_size_1 &lt;- ode(func = exponential_model, times = times, y = state, parms = parms, method = &quot;euler&quot;) # compare different method par(mfrow = c(1,2)) plot(N ~ time, data = pop_size, main = &quot;LSODA&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_1, main = &quot;Euler&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve # minimize the time step times &lt;- seq(0, 10, by = 0.01) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r = 1.5) # intrinsic growth rate # default: LSODA pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # Euler&#39;s method pop_size_1 &lt;- ode(func = exponential_model, times = times, y = state, parms = parms, method = &quot;euler&quot;) # compare different method par(mfrow = c(1,2)) plot(N ~ time, data = pop_size, main = &quot;LSODA&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_1, main = &quot;Euler&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve Part 3 - Solving exponential growth model with fluctuating growth rate Consider the model \\[ \\frac{dN}{dt} = r(t)N \\ \\text{, } r(t) = \\overline{r} + \\sigma\\sin(\\omega t) \\] where \\(\\overline{r}\\) and \\(\\omega\\) are constants. The analytical solution of the ode model is \\[ N(t) = N_0\\exp\\{\\overline{r}t - \\frac{\\sigma}{\\omega}[\\cos(\\omega t) - 1]\\} \\] ###### part 3 ###### ### Model specification exponential_model_fluc &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = (r_bar + sigma*sin(omega*times))*N # exponential growth equation return(list(c(dN_dt))) # return the results }) } ### Parameters times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r_bar = 1.5, sigma = 5, omega = 2*pi) # intrinsic growth rate Plot \\(r(t)\\) ### Fluctuating growth rate r = parms[1] + parms[2]*sin(parms[3]*times) plot(r ~ times, type = &quot;l&quot;) ### Solving model pop_size &lt;- ode(func = exponential_model_fluc, times = times, y = state, parms = parms) ### Plotting plot(N ~ times, data = pop_size) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve plot(N ~ times, data = pop_size, log = &quot;y&quot;) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve Adjust \\(\\overline{r}\\) ### Parameters times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r_bar = 0.1, sigma = 5, omega = 2*pi) # intrinsic growth rate ### Fluctuating growth rate r = parms[1] + parms[2]*sin(parms[3]*times) plot(r ~ times, type = &quot;l&quot;) ### Solving model pop_size &lt;- ode(func = exponential_model_fluc, times = times, y = state, parms = parms) ### Plotting plot(N ~ times, data = pop_size) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve "],["week-3---logistic-population-growth-and-stability-analysis.html", "Week 3 - Logistic population growth and stability analysis", " Week 3 - Logistic population growth and stability analysis Credit to Gen-Chang Hsu "],["week-4---discrete-exponential-and-logistic-models.html", "Week 4 - Discrete exponential and logistic models", " Week 4 - Discrete exponential and logistic models Part 1 - Model the discrete logistic population growth using for loops Model: \\[ N_{t+1} = N_t(1+r(1-\\frac{N_t}{K})) \\] ### (1) Define the discrete logistic growth equation log_fun &lt;- function(r, N, K){N + r*N*(1-N/K)} You may modify \\(r\\) to see the change in stability of equilibrium \\(K\\). ### (2) Set the parameters r &lt;- 1.8 K &lt;- 500 N0 &lt;- 10 time &lt;- 100 ### (3) Use for loop to iterate over the time sequence pop_size &lt;- data.frame(times = 1:time) pop_size$N[1] &lt;- N0 head(pop_size) ## times N ## 1 1 10 ## 2 2 10 ## 3 3 10 ## 4 4 10 ## 5 5 10 ## 6 6 10 for(i in 2:time){ pop_size$N[i] &lt;- log_fun(r = r, N = pop_size$N[i - 1], K = K) } head(pop_size) ## times N ## 1 1 10.00000 ## 2 2 27.64000 ## 3 3 74.64171 ## 4 4 188.93980 ## 5 5 400.51775 ## 6 6 543.95762 ### (4) Population trajectory plot(N ~ times, data = pop_size, type = &quot;l&quot;) abline(h = K, col = &quot;red&quot;) points(N ~ times, data = pop_size) Here is a shiny app for the discrete logistic growth model. Credit to Gen-Chang Hsu Part 2 - Bifurcation ###### Part 2: Bifurcation curve ### (1) data setting # intrinsic growth rate sequence r_seq &lt;- seq(from = 1.8, to = 3, by = 0.01) # number of sampling N_rep &lt;- 200 # data dat_plot &lt;- data.frame(r = rep(r_seq, each = N_rep), N = 0) head(dat_plot) ## r N ## 1 1.8 0 ## 2 1.8 0 ## 3 1.8 0 ## 4 1.8 0 ## 5 1.8 0 ## 6 1.8 0 ### (2) Run the discrete logistic model for (lo in 1:length(r_seq)){ log_fun &lt;- function(r, N, K){N + r*N*(1-N/K)} r &lt;- r_seq[lo] K &lt;- 500 N0 &lt;- 10 time &lt;- 1000 pop_size &lt;- data.frame(times = 1:time) pop_size$N[1] &lt;- N0 for(i in 2:time){ pop_size$N[i] &lt;- log_fun(r = r, N = pop_size$N[i - 1], K = K) } # save the data dat_plot$N[(1 + (lo - 1)*N_rep):(lo*N_rep)] &lt;- pop_size$N[(nrow(pop_size) - N_rep + 1):nrow(pop_size)] } plot(N ~ r, data = dat_plot, cex = 0.7, pch = 20) "],["week-5---age-structure-population-model.html", "Week 5 - Age-structure population model", " Week 5 - Age-structure population model In this lab section, we will analyze a Leslie matrix using for loops and matrix algebra, compare the results with those obtained via eigen-analysis, and visualize the population dynamics and age distribution. Part 1 - Visualizing stable age distribution For any diagonalizable n-by-n matrix \\(M\\) with only one dominant eigenvalue, and for any n-by-1 vector \\(v\\), \\(M^tv\\) will shift to the same direction with the eigenvector of \\(M\\) corresponding to the dominant eigenvalue when \\(t\\) is large. Here, we visualize this fact numerically. library(ggplot2) set.seed(1234) MAT &lt;- matrix(rnorm(25), ncol = 5, nrow = 5) abs(eigen(MAT)$values) # check only one dominant eigenvalue ## [1] 2.2734833 1.6266143 0.6187862 0.6187862 0.3970850 eig_vec1 &lt;- as.numeric(eigen(MAT)$vector[, 1]) v &lt;- rnorm(5) time &lt;- 15 dat_v &lt;- data.frame(matrix(ncol = 5, nrow = time)) dat_v[1, ] &lt;- v for(i in 2:time){ dat_v[i, ] &lt;- MAT %*% t(dat_v[i-1, ]) } # Remake data for gganimate dat &lt;- data.frame(X1 = 0, X2 = 0, Time = 1) for(i in 1:time){ dat &lt;- rbind(dat, data.frame(dat_v[i,1:2] / sqrt(sum(dat_v[i,1:2]^2)) * i, Time = i)) dat &lt;- rbind(dat, c(0,0, i+1)) } dat &lt;- dat[-nrow(dat), ] ggplot(dat, aes(X1, X2, color = Time)) + geom_path(arrow = arrow(length = unit(0.55, &quot;cm&quot;))) + geom_abline(intercept = 0, slope = eig_vec1[2]/eig_vec1[1], color = &quot;red&quot;, linetype = &quot;dashed&quot;) # red dashed eigenvector Part 2 - Analyzing Leslie matrix Consider an age-strutured population model \\[ n_{t} = L^tn_0 \\] where \\(L\\) is a Leslie matrix and \\(n_t = (n_{1,t}, n_{2,t}, n_{3,t})\\) is the population sizes with three different ages in time \\(t\\). ### Leslie matrix and initial age classes leslie &lt;- matrix(data = c(0, 1, 5, 0.5, 0, 0, 0, 0.3, 0), nrow = 3, ncol = 3, byrow = T) N0 &lt;- c(10, 0, 0) ### for loop and matrix algebra time &lt;- 50 pop_size &lt;- data.frame(Age1 = 0, Age2 = 0, Age3 = 0) pop_size[1, ] &lt;- N0 for (i in 2:time) { # Matrix multiplication pop_size[i, ] &lt;- leslie %*% t(pop_size[i-1, ]) } # Total abundance pop_size$N &lt;- rowSums(pop_size) head(pop_size) ## Age1 Age2 Age3 N ## 1 10.0 0.00 0.000 10.000 ## 2 0.0 5.00 0.000 5.000 ## 3 5.0 0.00 1.500 6.500 ## 4 7.5 2.50 0.000 10.000 ## 5 2.5 3.75 0.750 7.000 ## 6 7.5 1.25 1.125 9.875 plot(c(1,time), c(0,265), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;pop_size&quot;) lines(1:time , pop_size$Age1, col = &quot;red&quot;) lines(1:time , pop_size$Age2, col = &quot;blue&quot;) lines(1:time , pop_size$Age3, col = &quot;green&quot;) legend(&quot;topleft&quot;, legend = c(&quot;Age1&quot;, &quot;Age2&quot;, &quot;Age3&quot;), col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), lty = 1) By the derivation in the class, the asymptotic population sizes can be approximated by \\[ n_t \\approx c\\cdot \\lambda_1^t\\cdot u_1 \\] where \\(c\\) is a constant, \\(\\lambda_1\\) is the dominant eigenvalue and \\(u_1\\) is the corresponding eigenvector. Hence, with the long-term dynamics, the population grows at a rate \\(\\lambda_1\\) and with the age distribution \\(u_1\\). Here, we check this fact numerically. ### Asymptotic growth rate and stable age distribution asymptotic_growth &lt;- pop_size$N[time]/pop_size$N[time-1] asymptotic_growth ## [1] 1.089992 age_distribution &lt;- pop_size[time, 1:3]/sum(pop_size[time, 1:3]) age_distribution ## Age1 Age2 Age3 ## 50 0.6309262 0.2894167 0.07965713 ### Eigen-analysis of the Leslie matrix EIGEN &lt;- eigen(leslie) EIGEN ## eigen() decomposition ## $values ## [1] 1.0899905+0.0000000i -0.5449953+0.6253475i -0.5449953-0.6253475i ## ## $vectors ## [,1] [,2] [,3] ## [1,] 0.9030054+0i 0.8418972+0.0000000i 0.8418972+0.0000000i ## [2,] 0.4142263+0i -0.3334136-0.3825709i -0.3334136+0.3825709i ## [3,] 0.1140082+0i -0.0250833+0.1818099i -0.0250833-0.1818099i abs(EIGEN$values[1]) # dominant eigenvalue ## [1] 1.089991 as.numeric(EIGEN$vectors[, 1] / sum(EIGEN$vectors[, 1])) # corresponding eigenvector ## [1] 0.63092527 0.28941777 0.07965696 The asymptotic growth rate and stable age distribution obtained from for loops and eigen-analysis are similar. Part 3 - In-class exercise: Analyzing population matrix of common teasel Common teasel (Dipsacus sylvestris) is a herbaceous plant commonly found in abandoned fields and meadows in North America. It has a complex life cycle consisting of various stages. The seeds may lie dormant for one or two years. Seeds that germinate form small rosettes, which will gradually transit into medium and eventually large rosettes. These rosettes (all three sizes) may remain in the same stage for years before entering the next stage. After undergoing vernalization, large (and a few medium) rosettes will form stalks and flower in the upcoming summer, set seeds once, and die. Occasionally, the flowering plants will produce seeds that directly germinate into small/medium/large rosettes without entering dormancy. Here is a transition diagram for the teasel. Please convert this diagram into a stage-based transition matrix (Lefkovitch matrix) and derive the asymptotic growth rate \\(\\lambda\\) in R. Part 4 - COM(P)ADRE: A global database of population matrices COM(P)ADRE is an online repository containing matrix population models on hundreds of plants, animals, algae, fungi, bacteria, and viruses around the world, as well as their associated metadata. Take a look at the website: You will be exploring the population dynamics of a species (of your choice) in your assignment! "],["week-6---metapopulations-and-patch-occupancy-models.html", "Week 6 - Metapopulations and patch occupancy models", " Week 6 - Metapopulations and patch occupancy models Plants can condition nearby soil microbial communities, which will in turn influence the performance of subsequent colonizing plants. The soil beneath plant communities are therefore a mosaic with different cultivation histories. Po-Ju wants to understand how plant demographic rates (i.e., colonization and mortality rate) and microbial dynamics (i.e., the conditioning and decay rate of microbial communities) affect the percentage of different soil types in natural forests. As a starting point, Po-Ju builds a one-species patch occupancy model to track the dynamics of different types of plant-soil combination. In this model, he characterizes sites by their plant-soil microbe state, using the notation \\(P_{ij}\\) to indicate sites that are now occupied by plant species \\(i\\) but have soil microbes state \\(j\\). Here, as a single species model, \\(i\\) can be 0 or \\(A\\), representing uncolonized sites or sites colonized by plant \\(A\\), respectively. Similarly, \\(j\\) can be 0 or \\(A\\), indicating sites without recent plant conditioning history or sites conditioned by plant \\(A\\), respectively. In summary: \\(P_{00}\\) represents uncolonized and unconditioned sites \\(P_{A0}\\) represents cites colonized by plant \\(A\\) but the soil is yet to be conditioned \\(P_{AA}\\) represents plant \\(A\\) colonizing a site with plant-\\(A\\)-specific microbial community \\(P_{0A}\\) represents sites that are currently unoccupied but have soil microbes that were associated with plant \\(A\\) At the landscape scale, \\(P_{ij}\\) represents the proportion of sites belonging to a particular plant-soil microbe state, and its dynamics, \\(\\frac {dP_{ij}}{dt}\\), summarizes the processes of plant colonization and death. The transitions between different plant-soil microbe states can be described by the following figure. Here, \\(P_{00}\\) can be colonized by plant \\(A\\) when propagules arrive (per capita rate \\(r_{A}\\)), transitioning the state from \\(P_{00}\\) to \\(P_{A0}\\). Plants may die, with rate \\(m_{A}\\), before conditioning the soil (i.e., transition from \\(P_{A0}\\) back to \\(P_{00}\\)), or may successfully condition the soil with rate \\(c_{A}\\) (i.e., transition from \\(P_{A0}\\) to \\(P_{AA}\\)). After plants within the state \\(P_{AA}\\) die, a site with microbial legacy is left behind, denoted as \\(P_{0A}\\). These empty sites can be recolonized (i.e., transition from \\(P_{0A}\\) back to \\(P_{AA}\\)) with rates affected by the microbial legacy effect, \\(\\alpha\\). Finally, the microbial community within the soil may decay to unconditioned state with rate \\(d_{A}\\), transitioning the state from \\(P_{0A}\\) to \\(P_{00}\\). In this lab, we are going to model the dynamics of this plant-soil system. We will start by converting the flow diagram into a set of differential equations and then solve them numerically using the package deSolve. library(deSolve) library(ggplot2) library(tidyr) ### Model specification PSF &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dP00_dt = P0A*dA + PA0*mA - P00*(PA0 + PAA)*rA dPA0_dt = P00*(PA0 + PAA)*rA - PA0*mA - PA0*cA dPAA_dt = PA0*cA - PAA*mA + P0A*(PA0 + PAA)*rA*alpha dP0A_dt = PAA*mA - P0A*(PA0 + PAA)*rA*alpha - P0A*dA return(list(c(dP00_dt, dPA0_dt, dPAA_dt, dP0A_dt))) }) } ### Model parameters times &lt;- seq(0, 20, by = 0.1) state &lt;- c(P00 = 0.25, PA0 = 0.25, PAA = 0.25, P0A = 0.25) parms &lt;- c(rA = 0.5, mA = 0.1, cA = 0.5, dA = 0.4, alpha = 0.7) ### ODE solver pop_size &lt;- ode(func = PSF, times = times, y = state, parms = parms) # take a look at the results head(pop_size) ## time P00 PA0 PAA P0A ## [1,] 0.0 0.2500000 0.2500000 0.2500000 0.2500000 ## [2,] 0.1 0.2558649 0.2416153 0.2640144 0.2385055 ## [3,] 0.2 0.2609930 0.2339241 0.2773399 0.2277430 ## [4,] 0.3 0.2654349 0.2268709 0.2900255 0.2176687 ## [5,] 0.4 0.2692386 0.2204039 0.3021162 0.2082413 ## [6,] 0.5 0.2724484 0.2144756 0.3136533 0.1994227 tail(pop_size) ## time P00 PA0 PAA P0A ## [196,] 19.5 0.1283001 0.08252532 0.6866677 0.1025070 ## [197,] 19.6 0.1282914 0.08250852 0.6866865 0.1025136 ## [198,] 19.7 0.1282832 0.08249240 0.6867045 0.1025199 ## [199,] 19.8 0.1282754 0.08247693 0.6867217 0.1025260 ## [200,] 19.9 0.1282679 0.08246208 0.6867382 0.1025319 ## [201,] 20.0 0.1282608 0.08244784 0.6867539 0.1025375 ### Visualization I pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;patch&quot;, value = &quot;proportion&quot;, -time) %&gt;% ggplot(aes(x = time, y = proportion, color = patch)) + geom_line(size = 1.5) ### Visualization II plot(range(times), c(0,1), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;proportion&quot;) lines(P00 ~ time, data = pop_size, col = &quot;tomato&quot;) lines(P0A ~ time, data = pop_size, col = &quot;navy&quot;) lines(PA0 ~ time, data = pop_size, col = &quot;gray&quot;) lines(PAA ~ time, data = pop_size, col = &quot;orange&quot;) legend(&quot;topleft&quot;, legend = c(&quot;P00&quot;, &quot;P0A&quot;, &quot;PA0&quot;, &quot;PAA&quot;), col = c(&quot;tomato&quot;, &quot;navy&quot;, &quot;gray&quot;, &quot;orange&quot;), lty = 1) "],["week-7---lotka-volterra-competition-model---population-dynamics.html", "Week 7 - Lotka-Volterra competition model - Population dynamics", " Week 7 - Lotka-Volterra competition model - Population dynamics In this lab, we are going to analyze the two-species Lotka-Volterra competition model numerically and visualize the population dynamics under different parameter settings. library(ggplot2) library(tidyverse) library(deSolve) LV_model &lt;- function(r1 = 1.4, r2 = 1.2, a11 = 1/200, a21 = 1/400, a22 = 1/200, a12 = 1/300, N1_0 = 10, N2_0 = 10) { ### Model specification LV &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = N1 * (r1 - a11*N1 - a12*N2) dN2_dt = N2 * (r2 - a22*N2 - a21*N1) return(list(c(dN1_dt, dN2_dt))) }) } ### Model parameters times &lt;- seq(0, 100, by = 0.1) state &lt;- c(N1 = N1_0, N2 = N2_0) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) ### Model application pop_size &lt;- ode(func = LV, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;pop_size&quot;, -time) %&gt;% ggplot(aes(x = time, y = pop_size, color = Species)) + geom_line(size = 1.5) } ### Different parameter settings ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/100, a12 = 1/200, N1_0 = 200, N2_0 = 5) # N1 wins ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/100, a12 = 1/200, N1_0 = 10, N2_0 = 200) # N1 wins ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/200, a12 = 1/100, N1_0 = 200, N2_0 = 5) # N2 wins ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/200, a12 = 1/100, N1_0 = 5, N2_0 = 200) # N2 wins ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/300, N1_0 = 200, N2_0 = 5) # stable coexistence ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/300, N1_0 = 5, N2_0 = 200) # stable coexistence ## N1_0 = 200 and N2_0 = 150 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, N1_0 = 200, N2_0 = 150) # priority effect (N1 wins) ## N1_0 = 150 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, N1_0 = 150, N2_0 = 200) # priority effect (N2 wins) #### phase diagram phase_plane &lt;- function(r1, r2, a11, a21, a22, a12, title, t){ ### Vectors LV &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = N1 * (r1 - a11*N1 - a12*N2) dN2_dt = N2 * (r2 - a22*N2 - a21*N1) return(list(c(dN1_dt, dN2_dt))) }) } times &lt;- c(0, t) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) x_inter&lt;- max(c(r1/a11, r2/a21)) y_inter &lt;- max(c(r2/a22, r1/a12)) # create position of arrows vector_grid &lt;- expand.grid(seq(5, x_inter, length.out = 10), seq(5, y_inter, length.out = 10)) vector_data &lt;- vector_grid %&gt;% pmap(., function(Var1, Var2){ state &lt;- c(N1 = Var1, N2 = Var2) pop_size &lt;- ode(func = LV, times = times, y = state, parms = parms) pop_size[2, 2:3] }) %&gt;% bind_rows() %&gt;% rename(xend = N1, yend = N2) %&gt;% bind_cols(vector_grid) %&gt;% rename(x = Var1, y = Var2) ### Phase plane ggplot() + geom_abline(slope = -a11/a12, intercept = r1/a12, color = &quot;#E41A1C&quot;, size = 1.5) + geom_abline(slope = -a21/a22, intercept = r2/a22, color = &quot;#377EB8&quot;, size = 1.5) + geom_segment(data = vector_data, aes(x = x, y = y, xend = xend, yend = yend), arrow = arrow(length = unit(0.1, &quot;cm&quot;))) + scale_x_continuous(name = &quot;N1&quot;, limits = c(0, x_inter), expand = c(0, 0)) + scale_y_continuous(name = &quot;N2&quot;, limits = c(0, y_inter), expand = c(0, 0)) + theme_bw(base_size = 13) + theme(panel.grid = element_blank(), plot.title = element_text(hjust = 0.5)) + labs(title = title) } phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/300, t = 0.3, title = &quot;Stable coexistence&quot;) phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, t = 0.3, title = &quot;Unstable coexistence (saddle)&quot;) "],["week-8---midterm.html", "Week 8 - Midterm", " Week 8 - Midterm "],["week-9---lotka-volterra-competition-model---visualization-of-dynamics-with-complex-eigenvalues.html", "Week 9 - Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues", " Week 9 - Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues Consider a linear system \\[ \\dfrac{d \\vec{\\pmb\\varepsilon}}{d t} = \\mathcal{J}\\vec{\\pmb\\varepsilon} \\] where \\(\\vec{\\pmb\\varepsilon} = (\\varepsilon_1, \\varepsilon_2)^T\\) and \\(\\mathcal{J} = \\begin{pmatrix} -1 &amp; 1\\\\ -2 &amp; -1 \\end{pmatrix}\\). Or, we can write the linear system by two ODEs: \\[\\begin{align*} \\dfrac{d \\varepsilon_1}{d t} &amp;= (-1)\\times \\varepsilon_1 + (1)\\times\\varepsilon_2\\\\ \\dfrac{d \\varepsilon_2}{d t} &amp;= (-2)\\times \\varepsilon_1 + (-1)\\times\\varepsilon_2\\\\ \\end{align*}\\] Note that the element in the first row and second column is positive. ## time e1 e2 ## [99996,] 9.9995 3.192479e-05 -6.443030e-05 ## [99997,] 9.9996 3.191516e-05 -6.443024e-05 ## [99998,] 9.9997 3.190552e-05 -6.443018e-05 ## [99999,] 9.9998 3.189589e-05 -6.443011e-05 ## [100000,] 9.9999 3.188626e-05 -6.443005e-05 ## [100001,] 10.0000 3.187663e-05 -6.442998e-05 "],["week-10---lotka-volterra-model-of-predator-prey-interactions-and-time-scale-separation.html", "Week 10 - Lotka-Volterra model of predator-prey interactions and time-scale separation", " Week 10 - Lotka-Volterra model of predator-prey interactions and time-scale separation Part 1: analyzing the classic Lotka-Volterra predator-prey model In this lab, we are going to analyze the classic Lotka-Volterra predator-prey model: \\[\\begin{align*} \\frac {dN}{dt} &amp;= rN-aNP\\\\ \\frac {dP}{dt} &amp;= eaNP-dP \\end{align*}\\] The non-trivial equilibrium of this system is \\(E_c = (N = \\frac{d}{ea}, P = \\frac{r}{a})\\). We simulate the model using the following parameter set (\\(N_0\\) = 10, \\(P_0\\) = 2, \\(r\\) = 1.0, \\(a\\) = 0.1, \\(e\\) = 0.8, \\(d\\) = 0.5) and plot the population trajectories of predator and prey over time. We also show their population dynamics in the state-space diagram. What will happen if you add a perturbation to the system (i.e., change the initial conditions)? Try out different values of \\(N\\) and \\(P\\) and visualize the differences in the state-space diagram by yourselve. library(deSolve) ### Model specification LV_predation_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N - a*N*P dP_dt = e*a*N*P - d*P return(list(c(dN_dt, dP_dt))) }) } ### Model parameters times &lt;- seq(0, 100, by = 0.01) state &lt;- c(N = 10, P = 2) parms &lt;- c(r = 1.0, a = 0.1, e = 0.8, d = 0.5) ### Model application pop_size &lt;- ode(func = LV_predation_model, times = times, y = state, parms = parms) ### Visualization -- population dynamics plot(c(0, max(times)), c(0, max(pop_size[, c(&quot;N&quot;, &quot;P&quot;)] + 10)), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;population size&quot;) lines(N ~ time, data = pop_size, col = &quot;blue&quot;) # dynamics of N lines(P ~ time, data = pop_size, col = &quot;red&quot;) # dynamics of P abline(h = parms[4]/(parms[3] * parms[2]), col = &quot;blue&quot;, lty = 2) # equilibrium of N abline(h = parms[1] / parms[2], col = &quot;red&quot;, lty = 2) # equilibrium of P legend(&quot;topright&quot;, legend = c(&quot;N&quot;, &quot;P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) ### Visualization -- state-space diagram plot(N ~ P, data = pop_size, type = &quot;l&quot;) points(parms[4]/(parms[3] * parms[2]), parms[1] / parms[2]) # equilibrium What is the relationship between the long-term average of the cycle and the originally-expected equilibrium? To calculate long-term average, we need to find out the period of the cycle and then calculate the average population size within a period. The period of the cycle may be derived from the distance between peaks in the dynamics shown above, or by some algorithms, e.g. pracma::findpeaks. Part 2: Time-scale separation Time-scale separation is a useful technique to reduce the dimension of the model system, where some state variables are assumed to operate at a much shorter time scale (i.e., fast variables) compared with the others (i.e., slow variables). The fast variables will be attracted rapidly to their new equilibrium in response to a slight change in the slow variables, such that the slow variables can be viewed as “constants” from the perspective of fast variables (and the fast variable will always be at its quasi-equilibrium from the perspective of the slow variable). Here, we are going to use the Lotka-Volterra model with logistic prey growth to demonstrate the time-scale separation technique: \\[\\begin{align*} \\frac {dN}{dt} &amp;= rN(1-\\frac{N}{K})-aNP\\\\ \\frac {dP}{dt} &amp;= eaNP-dP \\end{align*}\\] The ZNGIs of \\(N\\) are \\(N = 0\\) and \\(r(1-\\frac{N}{K}) - aP = 0\\) and the ZNGIs of \\(P\\) are \\(P = 0\\) and \\(eaN = d\\) in this model. We treat prey as a fast variable and predator as a slow variable. First, we find the quasi-equilibrium \\(\\widehat{N}\\) of prey by setting the prey equation to zero: \\[\\widehat{N} = K(1-\\frac{aP}{r})\\] And then we plug \\(\\widehat{N}\\) into predator equation: \\[\\frac {dP}{dt} = (eaK-d)P(1-\\frac{eaK(\\frac{a}{r})}{eaK-d}P)\\] One simple way to achieve time-scale separation in this model is to increase the prey growth rate so that prey will grow much faster than predator, mimicking the shorter generation time of prey relative to that of predator. library(deSolve) Prey_logistic_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(1-(N/K))-a*N*P dP_dt = e*a*N*P-d*P return(list(c(dN_dt, dP_dt))) }) } times &lt;- seq(0, 100, by = 0.01) state &lt;- c(N = 40, P = 20) parms &lt;- c(r = 40, K = 60, a = 0.1, e = 0.1, d = 0.5) # r is chosen to be sufficiently large for time-scale separation pop_size &lt;- ode(func = Prey_logistic_model, times = times, y = state, parms = parms) Under time-scale separation, population of prey rapidly becomes stable and predator exhibits a logistic growth. We show these by the trajectories of \\(P\\) and \\(N\\) over time. # population trajectories plot(c(0, max(times)), c(0, max(pop_size[, c(&quot;N&quot;, &quot;P&quot;)] + 10)), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;population size&quot;) lines(N ~ time, data = pop_size, col = &quot;blue&quot;) # dynamics of N lines(P ~ time, data = pop_size, col = &quot;red&quot;) # dynamics of P legend(&quot;topright&quot;, legend = c(&quot;N&quot;, &quot;P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) Since \\(N\\) is a fast variable, it will immediately achieve the its ZNGI on the state-space diagram. # state-space diagram plot(c(0, max(pop_size[, &quot;N&quot;])), c(0, max(pop_size[, &quot;P&quot;])), type = &quot;n&quot;, xlab = &quot;N&quot;, ylab = &quot;P&quot;) abline(v = 0, col = &quot;blue&quot;) # ZNGI of N abline(a = parms[1]/parms[3], b = -parms[1]/(parms[3]*parms[2]), col = &quot;blue&quot;) # ZNGI of N abline(h = 0, col = &quot;red&quot;) # ZNGI of P abline(v = parms[5]/(parms[4]*parms[3]), col = &quot;red&quot;) # ZNGI of P points(P ~ N, data = pop_size, col = &quot;gray&quot;) Play with the growth rate \\(r\\) from small to large values and see how the trajectory of prey and predator moves along the state-space. Shiny app is credit to Gen-Chang Hsu "],["week-11---no-class-due-to-ntu-anniversary.html", "Week 11 - No class due to NTU anniversary", " Week 11 - No class due to NTU anniversary "],["week-12---rosenzweig-macarthur-predator-prey-model-and-mays-complexity-stability-relationship.html", "Week 12 - Rosenzweig-MacArthur predator-prey model and May’s complexity-stability relationship", " Week 12 - Rosenzweig-MacArthur predator-prey model and May’s complexity-stability relationship Part 1: Rosenzweig–MacArthur predator–prey model In this lab we are going to analyze the Rosenzweig–MacArthur predator–prey model: \\[\\begin{align*} \\frac {dN}{dt} &amp;= rN(1-\\frac{N}{K})-a\\frac{N}{1+ahN}P\\\\ \\frac {dP}{dt} &amp;= ea\\frac{N}{1+ahN}P-dP,\\\\ \\end{align*}\\] where \\(r\\) is the intrinsic growth rate of prey, \\(K\\) is the carrying capacity of prey, \\(a\\) is the rate of prey being consumed by predator, \\(h\\) is the handling time of predator, \\(e\\) is the assimilation rate of predation and \\(d\\) is the mortality rate of predator. The ZNGIs of \\(N\\) are \\[ N = 0 \\text{ and } P = \\frac{r}{a}(1-\\frac{N}{K})(1+ahN) \\] and the ZNGIs of \\(P\\) are \\[ P = 0 \\text{ and } N = \\frac{d}{a(e-dh)} \\] The coexistence equilibrium is \\(E_{np} = \\left(N^* = \\frac{d}{a(e-dh)}, P^* = \\frac{r}{a}(1-\\frac{N^*}{K})(1+ahN^*)\\right)\\). Please simulate the model using the parameter set (\\(N_0\\) = 5, \\(P_0\\) = 2, \\(r\\) = 1.0, \\(K\\) = 5.0, \\(a\\) = 1.3, \\(h\\) = 0.9, \\(e\\) = 0.6, \\(d\\) = 0.5) and plot the population trajectories of predator and prey as well as show their population dynamics in the state-space diagram. library(deSolve) ### Model specification RM_predation_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(1-(N/K))-(a*N/(1+a*h*N))*P dP_dt = e*(a*N/(1+a*h*N))*P-d*P return(list(c(dN_dt, dP_dt))) }) } ### Model parameters times &lt;- seq(0, 200, by = 0.01) state &lt;- c(N = 5, P = 2) parms &lt;- c(r = 1.0, K = 5.0, a = 1.3, h = 0.9, e = 0.6, d = 0.5) ### Model application pop_size &lt;- ode(func = RM_predation_model, times = times, y = state, parms = parms) ### equilibrium E_np &lt;- with(as.list(parms), c(N = d/(a*(e-d*h)), P = r/a*(1-d/(a*(e-d*h))/K)*(1+a*h*d/(a*(e-d*h))))) ### Visualize the population dynamics # population trajectories plot(c(0, max(times)), c(0, max(pop_size[, c(&quot;N&quot;, &quot;P&quot;)])), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;population size&quot;) lines(N ~ time, data = pop_size, col = &quot;blue&quot;) # dynamics of N lines(P ~ time, data = pop_size, col = &quot;red&quot;) # dynamics of P legend(&quot;topright&quot;, legend = c(&quot;N&quot;, &quot;P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) # state-space diagram max_P &lt;- max(pop_size[ ,&quot;P&quot;]) max_N &lt;- max(pop_size[ ,&quot;N&quot;]) plot(P ~ N, data = pop_size, type = &quot;l&quot;, xlim = c(0, max_N*1.2), ylim = c(0, max_P*1.2)) points(E_np[&quot;P&quot;] ~ E_np[&quot;N&quot;], pch = 16) # equilibrium with(as.list(parms), { # ZNGIs of N abline(v = 0, col = &quot;blue&quot;) curve(r/a*(1-x/K)*(1+a*h*x), from = -2, to = K+2, col = &quot;blue&quot;, add = T) # ZNGIs of P abline(h = 0, col = &quot;red&quot;) abline(v = d/(a*(e-d*h)), col = &quot;red&quot;) }) legend(&quot;topright&quot;, legend = c(&quot;ZNGIs of N&quot;, &quot;ZNGIs of P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) Remark: with() is a function that you can load the value in the object without subsetting. Now we increase the carry capacity \\(K\\) to show the paradox of enrichment. Let’s consider \\(K = 7\\) with other parameters fixed. ### Model parameters times &lt;- seq(0, 200, by = 0.01) state &lt;- c(N = 5, P = 2) parms &lt;- c(r = 1.0, K = 7.0, a = 1.3, h = 0.9, e = 0.6, d = 0.5) ### Model application pop_size &lt;- ode(func = RM_predation_model, times = times, y = state, parms = parms) ### equilibrium E_np &lt;- with(as.list(parms), c(N = d/(a*(e-d*h)), P = r/a*(1-d/(a*(e-d*h))/K)*(1+a*h*d/(a*(e-d*h))))) The population size of \\(N\\) and \\(P\\) do not stay at the equilibrium but cycle. ### Visualize the population dynamics # population trajectories plot(c(0, max(times)), c(0, max(pop_size[, c(&quot;N&quot;, &quot;P&quot;)])*1.2), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;population size&quot;) lines(N ~ time, data = pop_size, col = &quot;blue&quot;) # dynamics of N lines(P ~ time, data = pop_size, col = &quot;red&quot;) # dynamics of P legend(&quot;topright&quot;, legend = c(&quot;N&quot;, &quot;P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) # state-space diagram max_P &lt;- max(pop_size[ ,&quot;P&quot;]) max_N &lt;- max(pop_size[ ,&quot;N&quot;]) plot(P ~ N, data = pop_size, type = &quot;l&quot;, xlim = c(0, max_N*1.2), ylim = c(0, max_P*1.2)) points(E_np[&quot;P&quot;] ~ E_np[&quot;N&quot;], pch = 16) # equilibrium with(as.list(parms), { # ZNGIs of N abline(v = 0, col = &quot;blue&quot;) curve(r/a*(1-x/K)*(1+a*h*x), from = -2, to = K+2, col = &quot;blue&quot;, add = T) # ZNGIs of P abline(h = 0, col = &quot;red&quot;) abline(v = d/(a*(e-d*h)), col = &quot;red&quot;) }) legend(&quot;topright&quot;, legend = c(&quot;ZNGIs of N&quot;, &quot;ZNGIs of P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) Do the long-term average of the population size equal to the equilibrium? Let’s calculate the long-term average of population size by function pracma::findpeaks(). It returns a matrix where each row represents one peak found. The first column gives the height, the second the position/index where the maximum is reached, the third and forth the indices of where the peak begins and ends — in the sense of where the pattern starts and ends. library(pracma) # find time points when local peaks occur peaks &lt;- findpeaks(pop_size[, &quot;N&quot;])[ ,2] peaks ## [1] 2219 5694 8960 12225 15490 18755 # get period as time between peaks periods &lt;- peaks[length(peaks)] - peaks[length(peaks) - 1] # long-term average of N avg_N &lt;- mean(pop_size[(length(times) - periods + 1):length(times), &quot;N&quot;]) avg_N ## [1] 3.642661 # long-term average of P avg_P &lt;- mean(pop_size[(length(times) - periods + 1):length(times), &quot;P&quot;]) avg_P ## [1] 1.4757 # equilibrium of N and P E_np ## N P ## 2.564103 1.949845 We show that the the long-term average of the population size of \\(N\\) and \\(P\\) are not identical to the equilibrium of \\(N\\) and \\(P\\). In fact, the long-term average of the resource \\(N\\) is larger than the original equilibrium due to the fact that the per capita growth rate of the \\(P\\) is a concave-downward function. What will happen if you add a perturbation to the system (i.e., change the initial conditions)? Try out different values of \\(N_0\\) and \\(P_0\\) and visualize the differences in the state-space diagram. Shiny app is credit to Gen-Chang Hsu Part 2: May’s complexity-stability relationship May’s insight was to skip the Jacobian calculation altogether and directly consider the Jacobian matrix as a large random matrix (\\(\\mathbf{M}\\), with elements \\(m_{ij}\\)) resting at a feasible equilibrium, and then the eigenvalues of the Jacobian matrix could be derived based on random matrix theory. Let’s try to recreate May’s random matrix. In particular, May considered the following algorithm to build the random Jacobian matrix for \\(S\\) species (thereby a \\(S \\times S\\) matrix): Here, \\(C\\) represents the connectedness of the system (chance of species interacting with each other), \\(\\sigma^{2}\\) can be considered as the realized interaction strengths, and \\(d\\) is the strength of self-limitation. # code for building May&#39;s random matrix BuildMay = function(S, C, d, sigma){ # fill the whole matrix entry &lt;- rnorm(S * S, mean = 0, sd = sigma) M &lt;- matrix(entry, nrow = S, ncol = S) # remove connections remove &lt;- matrix(runif(S * S) &lt;= C, nrow = S, ncol = S) M &lt;- M * remove sum(M != 0) / (S*S) # should equal to C # substrate diagonal elements by d diag(M) &lt;- diag(M) - d return(M) } May &lt;- BuildMay(S = 500, C = 0.5, d = 10, sigma = 1) EVals &lt;- eigen(May)$values Re.EVals &lt;- Re(EVals) Im.EVals &lt;- Im(EVals) plot(Re.EVals, Im.EVals, xlab = &quot;Real part&quot;, ylab = &quot;Imaginary part&quot;) abline(v = 0, col = &quot;red&quot;, lty = 2) Extra reading: Elliptic raw In May’s random matrix, the entries \\(m_{ij}\\), which represents the effect of species \\(j\\) on species \\(i\\)’s growth rate, are independently generated. However, in ecological networks, we usually model pairwise interaction such as consumer-resource, mutualism, and competition, in which cases, \\(m_{ij}\\) is not independent of \\(m_{ji}\\). For consumer-resources interactions, \\(m_{ij}\\) and \\(m_{ji}\\) are negatively correlated. For mutualism or competition interaction, \\(m_{ij}\\) and \\(m_{ji}\\) are positively correlated. Under the assumption that the pairwise interactions are correlated, we may show that the eigenvalues of the randomly generated Jacobian do not follow uniform distribution in a circle, but in an ellipse. We build a function BuildElliptic with argument \\(S\\) is the number of species (i.e. the dimension of the Jacobian), \\(C\\) is the connectance, \\(d\\) is the strength of self-limitation, \\(\\sigma\\) is the variance (i.e. the realized interaction strength) and \\(\\rho\\) is the correlation of the pairwise interaction. library(ggplot2) #### The function to build Elliptic law BuildElliptic &lt;- function(S, C, d, sigma, rho){ # sample coefficients in pairs pairs &lt;- MASS::mvrnorm(n = S * (S-1) / 2, mu = c(0, 0), Sigma = sigma^2 * matrix(c(1, rho, rho, 1), 2, 2)) # build a completely filled matrix M &lt;- matrix(0, S, S) M[upper.tri(M)] &lt;- pairs[,1] M &lt;- t(M) M[upper.tri(M)] &lt;- pairs[,2] # determine which connections to retain (in pairs) Connections &lt;- (matrix(runif(S * S), S, S) &lt;= C) * 1 Connections[lower.tri(Connections)] &lt;- 0 diag(Connections) &lt;- 0 Connections &lt;- Connections + t(Connections) M &lt;- M * Connections # set diagonals diag(M) &lt;- diag(M) - d return(M) } # consumer-resources interactions M_CR &lt;- BuildElliptic(S = 500, C = 0.3, d = 10, sigma = 1, rho = -0.5) EVals_CR &lt;- eigen(M_CR)$values Re.EVals_CR &lt;- Re(EVals_CR) Im.EVals_CR &lt;- Im(EVals_CR) # mutualism or competition M_MC &lt;- BuildElliptic(S = 500, C = 0.3, d = 10, sigma = 1, rho = 0.5) EVals_MC &lt;- eigen(M_MC)$values Re.EVals_MC &lt;- Re(EVals_MC) Im.EVals_MC &lt;- Im(EVals_MC) # combine data Re.EVals &lt;- c(Re.EVals_CR, Re.EVals_MC) Im.EVals &lt;- c(Im.EVals_CR, Im.EVals_MC) # visualization plot(Re.EVals, Im.EVals, xlab = &quot;Real part&quot;, ylab = &quot;Imaginary part&quot;, type = &quot;n&quot;) points(Re.EVals_CR, Im.EVals_CR, col = &quot;green&quot;) points(Re.EVals_MC, Im.EVals_MC, col = &quot;blue&quot;) abline(v = 0, col = &quot;red&quot;, lty = 2) legend(&quot;topleft&quot;, legend = c(&quot;Resource-consumer&quot;, &quot;Mutualism or Competition&quot;), col = c(&quot;green&quot;, &quot;blue&quot;), pch = 1) "],["week-13---parameter-space-for-apparent-competition-model.html", "Week 13 - Parameter space for apparent competition model", " Week 13 - Parameter space for apparent competition model Here, we are going to visualize the outcomes of apparent competition in the \\(r_1/a_1\\) – \\(r_2/a_2\\) space: \\[\\begin{align*} \\frac{dN_1}{dt} &amp;= r_1N_1(1-\\frac{N_1}{K_1}) - a_1N_1P\\\\ \\frac{dN_2}{dt} &amp;= r_2N_2(1-\\frac{N_2}{K_2}) - a_2N_2P\\\\ \\frac{dP}{dt} &amp;= e_1a_1N_1P + e_2a_2N_2P - mP. \\end{align*}\\] Two prey \\(N_1\\) and \\(N_2\\) grow logistically with intrinsic growth rate \\(r_1\\) and \\(r_2\\) and carrying capacity \\(K_1\\) and \\(K_2\\). Predator \\(P\\) consumes two prey following Holling type I functional response, with \\(a_1\\) and \\(a_2\\) representing the consumption rate of \\(N_1\\) and \\(N_2\\) by predator respectively. After consumption, the assimilation rate are \\(e_1\\) and \\(e_2\\). The death rate of predator is represented by \\(m\\). library(deSolve) library(ggplot2) #### Create a function to evaluate the competition outcome Apparent_logistic_func &lt;- function(r1, r2, other.parameters){ # specify the model Apparent_logistic_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = r1 * N1 * (1 - N1 / K1) - a1 * N1 * P dN2_dt = r2 * N2 * (1 - N2 / K2) - a2 * N2 * P dP_dt = e1 * a1 * N1 * P + e2 * a2 * N2 * P - d * P return(list(c(dN1_dt, dN2_dt, dP_dt))) }) } # model parameters times &lt;- seq(0, 3000, by = 10) state &lt;- c(N1 = 0.1, N2 = 0.1, P = 1) parms &lt;- c(r1 = r1, r2 = r2, other.parameters) # run the ode pop_size &lt;- ode(func = Apparent_logistic_model, times = times, y = state, parms = parms) # return final population size N_final &lt;- nrow(na.omit(pop_size)) # remove NAN&#39;s return(pop_size[N_final, -1]) } #### Set up parameter space of interest Parms &lt;- c(r1 = 0.1, r2 = 0.1, a1 = 0.35, a2 = 0.35, e1 = 0.4, e2 = 0.5, d = 0.8, K1 = 15, K2 = 12) r_min &lt;- 0.1 r_max &lt;- 0.7 n &lt;- 100 r1.vec &lt;- seq(r_min, r_max, length.out = n) r2.vec &lt;- seq(r_min, r_max, length.out = n) #### Create parameter space and saving space comp_out &lt;- expand.grid(r1 = r1.vec, r2 = r2.vec) comp_out &lt;- as.data.frame(cbind(comp_out, matrix(0, nrow = dim(comp_out)[1], ncol = 3))) head(comp_out) ## r1 r2 1 2 3 ## 1 0.1000000 0.1 0 0 0 ## 2 0.1060606 0.1 0 0 0 ## 3 0.1121212 0.1 0 0 0 ## 4 0.1181818 0.1 0 0 0 ## 5 0.1242424 0.1 0 0 0 ## 6 0.1303030 0.1 0 0 0 #### Apply the function across the parameter space start_time &lt;- Sys.time() # starting time for(i in 1:dim(comp_out)[1]){ comp_out[i, 3:5] &lt;- Apparent_logistic_func(r1 = comp_out$r1[i], r2 = comp_out$r2[i], other.parameters = Parms[-c(1:2)]) } end_time &lt;- Sys.time() # ending time end_time - start_time # total time spent ## Time difference of 2.265923 mins #### Determine outcome status comp_out$Outcome &lt;- ifelse (comp_out[, 3] &lt; 1e-4, &quot;N2 win&quot;, ifelse(comp_out[, 4] &lt; 1e-4, &quot;N1 win&quot;, &quot;Coexist&quot;)) #### Visualize the competition outcomes in the grids -- base R x &lt;- comp_out$r1 / Parms[3] y &lt;- comp_out$r2 / Parms[4] z &lt;- as.factor(comp_out$Outcome) # Levels: Coexist N1 win N2 win color &lt;- c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;) plot(x, y, type = &quot;n&quot;, xlab = &quot;r1/a1&quot;, ylab = &quot;r2/a2&quot;) size &lt;- 0.008571429 #0.003/0.35 for(i in 1:length(z)){ rect(x[i] - size, y[i] - size, x[i] + size, y[i] + size, col = color[z[i]], border = color[z[i]]) } abline(a = 0, b = (1 - Parms[7] / (Parms[5] * Parms[3] * Parms[8])), lwd = 4) abline(a = 0, b = (1 - Parms[7] / (Parms[6] * Parms[4] * Parms[9]))^-1,, lwd = 4) text(0.5, 1.5, labels = &quot;N2 wins&quot;) text(1.5, 0.5, labels = &quot;N1 wins&quot;) text(1.5, 1.5, labels = &quot;Coexist&quot;) #### Visualize the competition outcomes in the grids -- ggplot ggplot(comp_out, aes(x = r1/Parms[3], y = r2/Parms[4], z = Outcome, fill = Outcome)) + geom_tile() + geom_abline(intercept = 0, slope = (1 - Parms[7] / (Parms[5] * Parms[3] * Parms[8])), size = 1.5) + geom_abline(intercept = 0, slope = (1 - Parms[7] / (Parms[6] * Parms[4] * Parms[9]))^-1, size = 1.5) + labs(x = expression(r[1]/a[1]), y = expression(r[2]/a[2])) + scale_x_continuous(limits = c(r_min/Parms[3], r_max/Parms[4]), expand = c(0, 0)) + scale_y_continuous(limits = c(r_min/Parms[3], r_max/Parms[4]), expand = c(0, 0)) + scale_fill_brewer(palette = &quot;Set1&quot;) + theme_bw(base_size = 14) + theme(panel.grid = element_blank()) + coord_fixed(ratio = 1) + annotate(geom = &quot;text&quot;, x = 0.5, y = 1.5, label = &quot;bold(bolditalic(N[2])~wins)&quot;, parse = T) + annotate(geom = &quot;text&quot;, x = 1.5, y = 1.5, label = &quot;bold(Coexist)&quot;, parse = T) + annotate(geom = &quot;text&quot;, x = 1.5, y = 0.5, label = &quot;bold(bolditalic(N[1])~wins)&quot;, parse = T) If the parameter space is extended and sliced into more tiny grid, the outcomes will be more complete: "],["week-14---resource-competition.html", "Week 14 - Resource competition", " Week 14 - Resource competition Part 1 - R* rule In this part of the lab section, we are going to analyze the consumer-resource dynamics with two consumers and one resource: \\[\\begin{align*} \\frac {dN_{1}}{dt} &amp;= e_{1}a_{1}RN_{1}-dN_{1}\\\\ \\frac {dN_{2}}{dt} &amp;= e_{2}a_{2}RN_{2}-dN_{2}\\\\ \\frac {dR}{dt} &amp;= d(S_{0}-R)-a_{1}RN_{1}-a_{2}RN_{2}\\\\ \\end{align*}\\] Please simulate the model using the parameter set (\\(N_{1(0)}\\) = 2, \\(N_{2(0)}\\) = 2, \\(R\\) = 0.1, \\(a_1\\) = 0.4, \\(a_2\\) = 0.6, \\(e_1\\) = 1, \\(e_2\\) = 1, \\(d\\) = 0.01, \\(S_0\\) = 0.1) and visualize the population trajectories of the two consumers as well as the resource. Below is a plot of resource level vs. consumers’ per capita growth rate. What would you predict about the system dynamics? library(tidyverse) library(deSolve) ### Parameters a1 &lt;- 0.4 a2 &lt;- 0.6 e1 &lt;- 1 e2 &lt;- 1 d &lt;- 0.01 S0 &lt;- 0.1 ### Resource level vs. consumers&#39; per capita population growth data.frame(R = seq(0, 0.1, 0.001)) %&gt;% mutate(N1 = e1*a1*R-d, N2 = e2*a2*R-d) %&gt;% gather(key = &quot;Species&quot;, value = &quot;Growth&quot;, N1:N2) %&gt;% ggplot(aes(x = R, y = Growth, color = Species)) + geom_line() + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;) + labs(x = &quot;Resource level&quot;, y = &quot;Per capita growth rate&quot;) + theme_classic(base_size = 14) ### Model specification CR_model_2C_1R &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1*R*N1 - d*N1 dN2_dt = e2*a2*R*N2 - d*N2 dR_dt = d*(S0-R) - a1*R*N1 - a2*R*N2 return(list(c(dN1_dt, dN2_dt, dR_dt))) }) } ### Model parameters times &lt;- seq(0.1, 1000, by = 0.1) state &lt;- c(N1 = 2, N2 = 2, R = 0.1) parms &lt;- c(a1 = 0.4, a2 = 0.6, e1 = 1, e2 = 1, d = 0.01, S0 = 0.1) ### Model application pop_size &lt;- ode(func = CR_model_2C_1R, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;N&quot;, N1:R) %&gt;% mutate(trophic = case_when(Species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = Species)) + geom_line(size = 1.5) + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 5)) + labs(x = &quot;Time&quot;, y = NULL) + scale_color_manual(name = NULL, values = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;)) We can see that \\(N_1\\) goes extinct, as predicted by the R* rule; the remaining consumer \\(N_2\\) and the resource \\(R\\) exhibit stable coexistence. Part 2 - Tilman’s resource ratio hypothesis Now we will extend the model in Part 1. into two consumers and two resources: \\[\\begin{align*} \\frac {dN_{1}}{dt} &amp;= e_{1}a_{1a}R_{a}N_{1}+e_{1}a_{1b}R_{b}N_{1}-dN_{1}\\\\ \\frac {dN_{2}}{dt} &amp;= e_{2}a_{2a}R_{a}N_{2}+e_{2}a_{2b}R_{b}N_{2}-dN_{2}\\\\ \\frac {dR_{a}}{dt} &amp;= d(S_{a}-R_{a})-a_{1a}R_{a}N_{1}-a_{2a}R_{a}N_{2}\\\\ \\frac {dR_{b}}{dt} &amp;= d(S_{b}-R_{b})-a_{1b}R_{b}N_{1}-a_{2b}R_{b}N_{2}\\\\ \\end{align*}\\] Here, the two consumers \\(N_1\\) and \\(N_2\\) compete for two substitutable resources \\(R_1\\) and \\(R_2\\). Under certain conditions, the two consumers are able to coexist: ### Model specification CR_model_2C_2R &lt;- function(time, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1a*Ra*N1 + e1*a1b*Rb*N1 - d*N1 dN2_dt = e2*a2a*Ra*N2 + e2*a2b*Rb*N2 - d*N2 dRa_dt = d*(Sa-Ra) - (a1a*N1*Ra) - (a2a*N2*Ra) dRb_dt = d*(Sb-Rb) - (a1b*N1*Rb) - (a2b*N2*Rb) return(list(c(dN1_dt, dN2_dt, dRa_dt, dRb_dt))) }) } ### Model parameters times &lt;- seq(0.1, 2000, by = 0.01) state &lt;- c(N1 = 0.05, N2 = 0.05, Ra = 0.3, Rb = 0.3) parms &lt;- c(a1a = 0.4, a1b = 0.8, a2a = 0.6, a2b = 0.5, e1 = 1, e2 = 1, d = 0.1, Sa = 0.3, Sb = 0.3) ### Model application pop_size &lt;- ode(func = CR_model_2C_2R, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;N&quot;, N1:Rb) %&gt;% mutate(trophic = case_when(Species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = Species)) + geom_line(size = 1.5) + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 8)) + labs(x = &quot;Time&quot;, y = NULL) + scale_x_continuous(limits = c(0, 2050), expand = c(0, 0)) + scale_y_continuous(limits = c(0, NA), expand = c(0, 0)) + scale_color_manual(name = NULL, values = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;purple&quot;)) The phase diagram also illustrates stable coexistence of the two consumers: ### Parameters a1a &lt;- 0.4 a1b &lt;- 0.8 a2a &lt;- 0.6 a2b &lt;- 0.5 e1 &lt;- 1 e2 &lt;- 1 d &lt;- 0.1 ### Slopes and intercepts of the ZNGI&#39;s ZNGI_slope_N1 &lt;- -a1a/a1b ZNGI_intercept_N1 &lt;- d/(e1*a1b) ZNGI_slope_N2 &lt;- -a2a/a2b ZNGI_intercept_N2 &lt;- d/(e2*a2b) ### Consumption vectors eqilibrium_Ra &lt;- (d/e1)*((a1b-a2b)/(a2a*a1b-a2b*a1a)) eqilibrium_Rb &lt;- (d/e2)*((a1a-a2a)/(a2b*a1a-a2a*a1b)) convec_df &lt;- data.frame(x = c(eqilibrium_Ra + 6*a1a*eqilibrium_Ra, eqilibrium_Ra + 6*a2a*eqilibrium_Ra), y = c(eqilibrium_Rb + 6*a1b*eqilibrium_Rb, eqilibrium_Rb + 6*a2b*eqilibrium_Rb), xend = c(eqilibrium_Ra - a1a*eqilibrium_Ra, eqilibrium_Ra - a2a*eqilibrium_Ra), yend = c(eqilibrium_Rb - a1b*eqilibrium_Rb, eqilibrium_Rb - a2b*eqilibrium_Rb), species = c(&quot;N1&quot;, &quot;N2&quot;)) ### Phase diagram ggplot() + geom_abline(slope = ZNGI_slope_N1, intercept = ZNGI_intercept_N1, color = &quot;#377EB8&quot;, size = 1.2) + geom_abline(slope = ZNGI_slope_N2, intercept = ZNGI_intercept_N2, color = &quot;#E41A1C&quot;, size = 1.2) + geom_segment(data = convec_df, aes(x = x, y = y, xend = xend, yend = yend, color = species), linetype = &quot;blank&quot;) + geom_segment(data = convec_df, aes(x = x, y = y, xend = xend, yend = yend, color = species), size = 0.5, linetype = &quot;dashed&quot;, arrow = arrow(type = &quot;closed&quot;, length = unit(0.1, &quot;inches&quot;)), show.legend = F) + geom_path(data = as.data.frame(pop_size), aes(x = Ra, y = Rb), size = 1.2) + geom_point(data = as.data.frame(pop_size), aes(x = last(Ra), y = last(Rb)), size = 2.5) + theme_classic(base_size = 14) + labs(x = expression(italic(R[a])), y = expression(italic(R[b]))) + scale_x_continuous(limits = c(0, 0.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, 0.5), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, direction = -1, guide = guide_legend(override.aes = list( linetype = &quot;solid&quot;, size = 1.2))) + coord_fixed(ratio = 1) In this particular case, if the initial resource levels \\(R_{a(0)}\\) and \\(R_{b(0)}\\) fall within the upper area bounded by the two consumption vectors, then the two species will coexist. Part 3 - Relative nonlinearity We have seen in Part 1. that two species cannot coexist on one resource if the consumers consume it in a linear fashion. What if the consumers consume the resource in a non-linear fashion? Could that generate stable coexistence? In this part of the lab section, we will introduce non-linear (type II) functional response into the consumer-resource model in Part 1. for one of the consumers. We also change the resource equation to logistic growth and allow the two consumers to have different conversion efficiencies and mortality rates: \\[\\begin{align*} \\frac {dN_{1}}{dt} &amp;= e_{1}a_{1}RN_{1}-d_{1}N_{1}\\\\ \\frac {dN_{2}}{dt} &amp;= e_{2}\\frac{a_{2}R}{k_{2}+R}N_{2}-d_{2}N_{2}\\\\ \\frac {dR}{dt} &amp;= rR(1-\\frac{R}{K})-a_{1}RN_{1}-\\frac{a_{2}R}{k_{2}+R}N_{2}\\\\ \\end{align*}\\] ### Model specification CR_model_nonlinear &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1*R*N1 - d1*N1 dN2_dt = e2*(a2*R/(k2+R))*N2 - d2*N2 dR_dt = r*R*(1-(R/K)) - a1*R*N1 - ((a2*R)/(k2+R))*N2 return(list(c(dN1_dt, dN2_dt, dR_dt))) }) } ### Model parameters times &lt;- seq(0, 5000, by = 0.1) state &lt;- c(N1 = 0.3, N2 = 19, R = 106) parms &lt;- c(a1 = 0.003, a2 = 0.5, k2 = 50, e1 = 0.33, e2 = 0.3, d1 = 0.11, d2 = 0.1, r = 0.1, K = 300) ### Model application pop_size &lt;- ode(func = CR_model_nonlinear, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;N&quot;, N1:R) %&gt;% mutate(trophic = case_when(Species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = Species)) + geom_line() + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 5)) + labs(x = &quot;Time&quot;, y = NULL) + scale_color_manual(name = NULL, values = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;)) As shown in the figure, the two consumers coexist in a fluctuating manner. In fact, the fluctuating properties generated by the combination of logistically growing resources and different nonlinear functions are critical for the coexistence of \\(n\\) species on \\(k&lt;n\\) resources in certain parameter spaces. "],["week-15---research-applications-modern-coexistence-theory-and-plant-soil-feedback.html", "Week 15 - Research applications: modern coexistence theory and plant-soil feedback", " Week 15 - Research applications: modern coexistence theory and plant-soil feedback "],["week-16---final-exam.html", "Week 16 - Final exam", " Week 16 - Final exam "]]
=======
[["index.html", "Introduction to Theoretical Ecology Course information", " Introduction to Theoretical Ecology Instructor: Po-Ju Ke \\(~~~~~\\) Teaching Assistant: Ching-Lin Huang (Andy) 2022 Fall at National Taiwan Univeristy Course information Description The development of theory plays an important role in advancing ecology as a scientific field. This three-unit course is for students at the graduate or advanced undergraduate level. The course will cover classic theoretical topics in ecology, starting from single-species dynamics and gradually build up to multi-species models. The course will primarily focus on population and community ecology, but we will also briefly discuss models in epidemiology and ecosystem ecology. Emphasis will be on theoretical concepts and corresponding mathematical approaches. This course is designed as a two-hour lecture followed by a one-hour hands-on practice module. In the lecture, we will analyze dynamical models and derive general theories in ecology. In the hands-on practice section, we will use a combination of analytical problem sets, interactive applications, and numerical simulations to gain a general understanding of the dynamics and behavior of different models. Objective By the end of the course, students are expected to be familiar with the basic building blocks of ecological models and would be able to formulate and analyze simple models of their own. The hands-on practice component should allow students to link their ecological intuition with the underlying mathematical model, helping them to better understand the primary literature of theoretical ecology. Requirement Students are expected to have a basic understanding of Calculus (e.g., freshman introductory course) and Ecology. Format Tuesday 6,7,8 (1:20 pm ~ 4:20 pm) at 共207 Grading The final grade consists of: Assignment problem sets (60%) Midterm exam (15%) Final exam (15%) Course participation (10%) Course materials We will be using a combination of textbooks and literature articles on theoretical ecology in this course. Textbook chapters and additional reading materials will be provided (see Syllabus for more details). Below are the textbook references: A Primer of Ecology 4th edition. Nicholas Gotelli, 2008. An Illustrated Guide to Theoretical Ecology. Ted Case, 2000. A Biologist’s Guide to Mathematical Modeling in Ecology and Evolution. Sarah Otto &amp; Troy Day, 2011. Mathematical Ecology of Populations and Ecosystems. John Pastor, 2008. Contacts Instructor: Po-Ju Ke Office: Life Science Building R635 Email: pojuke@ntu.edu.tw Office hours: by appointment Teaching assistant: Ching-Lin Huang (Andy) Office: Life Science Building R635 Email: r09b44010@ntu.edu.tw Office hours: 14:00 ~ 15:00 on Thursday "],["syllabus.html", "Syllabus", " Syllabus Date Lecture topic Lab Readings Week 1 9/6 Introduction: what is theoretical ecology? - Grainger et al., 2021 Week 2 9/13 Exponential population growth Solving exponential growth equation using “deSolve” &amp; Visualization - Week 3 9/20 Logistic population growth and stability analysis Shinny App for logistic population growth - Week 4 9/27 Discrete population models Discrete logistic population growth model and bifurcation - Week 5 10/4 Age-structured population models Age-structured population model - Week 6 10/11 Metapopulations and patch occupancy models Metapopulations and patch occupancy models - Week 7 10/18 Lotka-Volterra model of competition: graphical analysis Lotka-Volterra competition model - Population dynamics - Week 8 10/25 Midterm exam - - Week 9 11/1 Lotka-Volterra model of competition: invasion analysis and linear stability analysis Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues - Week 10 11/8 Predator-prey interactions (I) and time scale separation Lotka-Volterra model of predator-prey interactions and time-scale separation - Week 11 11/15 No class due to NTU anniversary - - Week 12 11/22 Predator-prey interactions (II) and complexity-stability relationship Rosenzweig-MacArthur predator-prey model and May’s complexity-stability relationship - Week 13 11/29 Multispecies models of competition: consumer-resource dynamics Parameter space for apparent competition model - Week 14 12/6 Multispecies models of predation: apparent competition Resource competition - Week 15 12/13 Research applcations: plant-soil feedback as an example - - Week 16 12/20 Final exam - - "],["week-2---exponential-population-growth.html", "Week 2 - Exponential population growth", " Week 2 - Exponential population growth In part 1, we will solve the differential equation for exponential population growth and visualize how the population sizes change over time. Part 1 - Numerical solution using the package “deSolve” Two main phases: Model specification: specify the structure of differential equation model Model application: set the time steps, initial population size and model parameters (e.g., intrinsic population growth rate r), and then solve the equation model p span#aaa:before { content: \"(1) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } p span#bbb:before { content: \"(2) \"; display: inline-block; margin-left: -1.5em; margin-right: 0.3em; } d-article table.lightable-paper { margin-bottom: 0px; } Consider the model \\[ \\frac{dN}{dt} = rN \\] where \\(N\\) is population size and \\(r\\) is the intrinsic growth rate. ###### part 1 ###### # install.packages(&quot;deSolve&quot;) library(deSolve) ### (1) Model specification exponential_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N # exponential growth equation return(list(c(dN_dt))) # return the results }) } Set the time steps, initial population size and model parameters. ### (2) Model application times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r = 1.5) # intrinsic growth rate Solve the equation by ode() numerically. # run the ode solver pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # take a look at the results head(pop_size) ## time N ## [1,] 0.0 10.00000 ## [2,] 0.1 11.61834 ## [3,] 0.2 13.49860 ## [4,] 0.3 15.68313 ## [5,] 0.4 18.22120 ## [6,] 0.5 21.17002 Visualization plot(N ~ time, data = pop_size) plot(N ~ time, data = pop_size, log = &quot;y&quot;) Part 2 - Comparing different ode solvers In default of ode(), the equations are solved by LSODA method. We can change the method by modifying the argument method in ode(). ###### part 2 ###### # original setting times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r = 1.5) # intrinsic growth rate # default: LSODA pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # Euler&#39;s method pop_size_1 &lt;- ode(func = exponential_model, times = times, y = state, parms = parms, method = &quot;euler&quot;) # compare different method par(mfrow = c(1,2)) plot(N ~ time, data = pop_size, main = &quot;LSODA&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_1, main = &quot;Euler&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve # minimize the time step times &lt;- seq(0, 10, by = 0.01) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r = 1.5) # intrinsic growth rate # default: LSODA pop_size &lt;- ode(func = exponential_model, times = times, y = state, parms = parms) # Euler&#39;s method pop_size_1 &lt;- ode(func = exponential_model, times = times, y = state, parms = parms, method = &quot;euler&quot;) # compare different method par(mfrow = c(1,2)) plot(N ~ time, data = pop_size, main = &quot;LSODA&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve plot(N ~ time, data = pop_size_1, main = &quot;Euler&quot;) curve(state[1]*exp(parms[1]*x), times[1], times[length(times)], col = &quot;red&quot;, add = T) # correct curve Part 3 - Solving exponential growth model with fluctuating growth rate Consider the model \\[ \\frac{dN}{dt} = r(t)N \\ \\text{, } r(t) = \\overline{r} + \\sigma\\sin(\\omega t) \\] where \\(\\overline{r}\\) and \\(\\omega\\) are constants. The analytical solution of the ode model is \\[ N(t) = N_0\\exp\\{\\overline{r}t - \\frac{\\sigma}{\\omega}[\\cos(\\omega t) - 1]\\} \\] ###### part 3 ###### ### Model specification exponential_model_fluc &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = (r_bar + sigma*sin(omega*times))*N # exponential growth equation return(list(c(dN_dt))) # return the results }) } ### Parameters times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r_bar = 1.5, sigma = 5, omega = 2*pi) # intrinsic growth rate Plot \\(r(t)\\) ### Fluctuating growth rate r = parms[1] + parms[2]*sin(parms[3]*times) plot(r ~ times, type = &quot;l&quot;) ### Solving model pop_size &lt;- ode(func = exponential_model_fluc, times = times, y = state, parms = parms) ### Plotting plot(N ~ times, data = pop_size) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve plot(N ~ times, data = pop_size, log = &quot;y&quot;) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve Adjust \\(\\overline{r}\\) ### Parameters times &lt;- seq(0, 10, by = 0.1) # time steps to integrate over state &lt;- c(N = 10) # initial population size parms &lt;- c(r_bar = 0.1, sigma = 5, omega = 2*pi) # intrinsic growth rate ### Fluctuating growth rate r = parms[1] + parms[2]*sin(parms[3]*times) plot(r ~ times, type = &quot;l&quot;) ### Solving model pop_size &lt;- ode(func = exponential_model_fluc, times = times, y = state, parms = parms) ### Plotting plot(N ~ times, data = pop_size) curve(state[1]*exp(parms[1]*x - parms[2]/parms[3]*(cos(parms[3]*x) - 1)), add = T, col = &quot;red&quot;) # correct curve "],["week-3---logistic-population-growth-and-stability-analysis.html", "Week 3 - Logistic population growth and stability analysis", " Week 3 - Logistic population growth and stability analysis Credit to Gen-Chang Hsu "],["week-4---discrete-exponential-and-logistic-models.html", "Week 4 - Discrete exponential and logistic models", " Week 4 - Discrete exponential and logistic models Part 1 - Model the discrete logistic population growth using for loops Model: \\[ N_{t+1} = N_t(1+r(1-\\frac{N_t}{K})) \\] ### (1) Define the discrete logistic growth equation log_fun &lt;- function(r, N, K){N + r*N*(1-N/K)} You may modify \\(r\\) to see the change in stability of equilibrium \\(K\\). ### (2) Set the parameters r &lt;- 1.8 K &lt;- 500 N0 &lt;- 10 time &lt;- 100 ### (3) Use for loop to iterate over the time sequence pop_size &lt;- data.frame(times = 1:time) pop_size$N[1] &lt;- N0 head(pop_size) ## times N ## 1 1 10 ## 2 2 10 ## 3 3 10 ## 4 4 10 ## 5 5 10 ## 6 6 10 for(i in 2:time){ pop_size$N[i] &lt;- log_fun(r = r, N = pop_size$N[i - 1], K = K) } head(pop_size) ## times N ## 1 1 10.00000 ## 2 2 27.64000 ## 3 3 74.64171 ## 4 4 188.93980 ## 5 5 400.51775 ## 6 6 543.95762 ### (4) Population trajectory plot(N ~ times, data = pop_size, type = &quot;l&quot;) abline(h = K, col = &quot;red&quot;) points(N ~ times, data = pop_size) Here is a shiny app for the discrete logistic growth model. Credit to Gen-Chang Hsu Part 2 - Bifurcation ###### Part 2: Bifurcation curve ### (1) data setting # intrinsic growth rate sequence r_seq &lt;- seq(from = 1.8, to = 3, by = 0.01) # number of sampling N_rep &lt;- 200 # data dat_plot &lt;- data.frame(r = rep(r_seq, each = N_rep), N = 0) head(dat_plot) ## r N ## 1 1.8 0 ## 2 1.8 0 ## 3 1.8 0 ## 4 1.8 0 ## 5 1.8 0 ## 6 1.8 0 ### (2) Run the discrete logistic model for (lo in 1:length(r_seq)){ log_fun &lt;- function(r, N, K){N + r*N*(1-N/K)} r &lt;- r_seq[lo] K &lt;- 500 N0 &lt;- 10 time &lt;- 1000 pop_size &lt;- data.frame(times = 1:time) pop_size$N[1] &lt;- N0 for(i in 2:time){ pop_size$N[i] &lt;- log_fun(r = r, N = pop_size$N[i - 1], K = K) } # save the data dat_plot$N[(1 + (lo - 1)*N_rep):(lo*N_rep)] &lt;- pop_size$N[(nrow(pop_size) - N_rep + 1):nrow(pop_size)] } plot(N ~ r, data = dat_plot, cex = 0.7, pch = 20) "],["week-5---age-structure-population-model.html", "Week 5 - Age-structure population model", " Week 5 - Age-structure population model In this lab section, we will analyze a Leslie matrix using for loops and matrix algebra, compare the results with those obtained via eigen-analysis, and visualize the population dynamics and age distribution. Part 1 - Visualizing stable age distribution For any diagonalizable n-by-n matrix \\(M\\) with only one dominant eigenvalue, and for any n-by-1 vector \\(v\\), \\(M^tv\\) will shift to the same direction with the eigenvector of \\(M\\) corresponding to the dominant eigenvalue when \\(t\\) is large. Here, we visualize this fact numerically. library(ggplot2) set.seed(1234) MAT &lt;- matrix(rnorm(25), ncol = 5, nrow = 5) abs(eigen(MAT)$values) # check only one dominant eigenvalue ## [1] 2.2734833 1.6266143 0.6187862 0.6187862 0.3970850 eig_vec1 &lt;- as.numeric(eigen(MAT)$vector[, 1]) v &lt;- rnorm(5) time &lt;- 15 dat_v &lt;- data.frame(matrix(ncol = 5, nrow = time)) dat_v[1, ] &lt;- v for(i in 2:time){ dat_v[i, ] &lt;- MAT %*% t(dat_v[i-1, ]) } # Remake data for gganimate dat &lt;- data.frame(X1 = 0, X2 = 0, Time = 1) for(i in 1:time){ dat &lt;- rbind(dat, data.frame(dat_v[i,1:2] / sqrt(sum(dat_v[i,1:2]^2)) * i, Time = i)) dat &lt;- rbind(dat, c(0,0, i+1)) } dat &lt;- dat[-nrow(dat), ] ggplot(dat, aes(X1, X2, color = Time)) + geom_path(arrow = arrow(length = unit(0.55, &quot;cm&quot;))) + geom_abline(intercept = 0, slope = eig_vec1[2]/eig_vec1[1], color = &quot;red&quot;, linetype = &quot;dashed&quot;) # red dashed eigenvector Part 2 - Analyzing Leslie matrix Consider an age-strutured population model \\[ n_{t} = L^tn_0 \\] where \\(L\\) is a Leslie matrix and \\(n_t = (n_{1,t}, n_{2,t}, n_{3,t})\\) is the population sizes with three different ages in time \\(t\\). ### Leslie matrix and initial age classes leslie &lt;- matrix(data = c(0, 1, 5, 0.5, 0, 0, 0, 0.3, 0), nrow = 3, ncol = 3, byrow = T) N0 &lt;- c(10, 0, 0) ### for loop and matrix algebra time &lt;- 50 pop_size &lt;- data.frame(Age1 = 0, Age2 = 0, Age3 = 0) pop_size[1, ] &lt;- N0 for (i in 2:time) { # Matrix multiplication pop_size[i, ] &lt;- leslie %*% t(pop_size[i-1, ]) } # Total abundance pop_size$N &lt;- rowSums(pop_size) head(pop_size) ## Age1 Age2 Age3 N ## 1 10.0 0.00 0.000 10.000 ## 2 0.0 5.00 0.000 5.000 ## 3 5.0 0.00 1.500 6.500 ## 4 7.5 2.50 0.000 10.000 ## 5 2.5 3.75 0.750 7.000 ## 6 7.5 1.25 1.125 9.875 plot(c(1,time), c(0,265), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;pop_size&quot;) lines(1:time , pop_size$Age1, col = &quot;red&quot;) lines(1:time , pop_size$Age2, col = &quot;blue&quot;) lines(1:time , pop_size$Age3, col = &quot;green&quot;) legend(&quot;topleft&quot;, legend = c(&quot;Age1&quot;, &quot;Age2&quot;, &quot;Age3&quot;), col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), lty = 1) By the derivation in the class, the asymptotic population sizes can be approximated by \\[ n_t \\approx c\\cdot \\lambda_1^t\\cdot u_1 \\] where \\(c\\) is a constant, \\(\\lambda_1\\) is the dominant eigenvalue and \\(u_1\\) is the corresponding eigenvector. Hence, with the long-term dynamics, the population grows at a rate \\(\\lambda_1\\) and with the age distribution \\(u_1\\). Here, we check this fact numerically. ### Asymptotic growth rate and stable age distribution asymptotic_growth &lt;- pop_size$N[time]/pop_size$N[time-1] asymptotic_growth ## [1] 1.089992 age_distribution &lt;- pop_size[time, 1:3]/sum(pop_size[time, 1:3]) age_distribution ## Age1 Age2 Age3 ## 50 0.6309262 0.2894167 0.07965713 ### Eigen-analysis of the Leslie matrix EIGEN &lt;- eigen(leslie) EIGEN ## eigen() decomposition ## $values ## [1] 1.0899905+0.0000000i -0.5449953+0.6253475i -0.5449953-0.6253475i ## ## $vectors ## [,1] [,2] [,3] ## [1,] 0.9030054+0i 0.8418972+0.0000000i 0.8418972+0.0000000i ## [2,] 0.4142263+0i -0.3334136-0.3825709i -0.3334136+0.3825709i ## [3,] 0.1140082+0i -0.0250833+0.1818099i -0.0250833-0.1818099i abs(EIGEN$values[1]) # dominant eigenvalue ## [1] 1.089991 as.numeric(EIGEN$vectors[, 1] / sum(EIGEN$vectors[, 1])) # corresponding eigenvector ## [1] 0.63092527 0.28941777 0.07965696 The asymptotic growth rate and stable age distribution obtained from for loops and eigen-analysis are similar. Part 3 - In-class exercise: Analyzing population matrix of common teasel Common teasel (Dipsacus sylvestris) is a herbaceous plant commonly found in abandoned fields and meadows in North America. It has a complex life cycle consisting of various stages. The seeds may lie dormant for one or two years. Seeds that germinate form small rosettes, which will gradually transit into medium and eventually large rosettes. These rosettes (all three sizes) may remain in the same stage for years before entering the next stage. After undergoing vernalization, large (and a few medium) rosettes will form stalks and flower in the upcoming summer, set seeds once, and die. Occasionally, the flowering plants will produce seeds that directly germinate into small/medium/large rosettes without entering dormancy. Here is a transition diagram for the teasel. Please convert this diagram into a stage-based transition matrix (Lefkovitch matrix) and derive the asymptotic growth rate \\(\\lambda\\) in R. Part 4 - COM(P)ADRE: A global database of population matrices COM(P)ADRE is an online repository containing matrix population models on hundreds of plants, animals, algae, fungi, bacteria, and viruses around the world, as well as their associated metadata. Take a look at the website: You will be exploring the population dynamics of a species (of your choice) in your assignment! "],["week-6---metapopulations-and-patch-occupancy-models.html", "Week 6 - Metapopulations and patch occupancy models", " Week 6 - Metapopulations and patch occupancy models Plants can condition nearby soil microbial communities, which will in turn influence the performance of subsequent colonizing plants. The soil beneath plant communities are therefore a mosaic with different cultivation histories. Po-Ju wants to understand how plant demographic rates (i.e., colonization and mortality rate) and microbial dynamics (i.e., the conditioning and decay rate of microbial communities) affect the percentage of different soil types in natural forests. As a starting point, Po-Ju builds a one-species patch occupancy model to track the dynamics of different types of plant-soil combination. In this model, he characterizes sites by their plant-soil microbe state, using the notation \\(P_{ij}\\) to indicate sites that are now occupied by plant species \\(i\\) but have soil microbes state \\(j\\). Here, as a single species model, \\(i\\) can be 0 or \\(A\\), representing uncolonized sites or sites colonized by plant \\(A\\), respectively. Similarly, \\(j\\) can be 0 or \\(A\\), indicating sites without recent plant conditioning history or sites conditioned by plant \\(A\\), respectively. In summary: \\(P_{00}\\) represents uncolonized and unconditioned sites \\(P_{A0}\\) represents cites colonized by plant \\(A\\) but the soil is yet to be conditioned \\(P_{AA}\\) represents plant \\(A\\) colonizing a site with plant-\\(A\\)-specific microbial community \\(P_{0A}\\) represents sites that are currently unoccupied but have soil microbes that were associated with plant \\(A\\) At the landscape scale, \\(P_{ij}\\) represents the proportion of sites belonging to a particular plant-soil microbe state, and its dynamics, \\(\\frac {dP_{ij}}{dt}\\), summarizes the processes of plant colonization and death. The transitions between different plant-soil microbe states can be described by the following figure. Here, \\(P_{00}\\) can be colonized by plant \\(A\\) when propagules arrive (per capita rate \\(r_{A}\\)), transitioning the state from \\(P_{00}\\) to \\(P_{A0}\\). Plants may die, with rate \\(m_{A}\\), before conditioning the soil (i.e., transition from \\(P_{A0}\\) back to \\(P_{00}\\)), or may successfully condition the soil with rate \\(c_{A}\\) (i.e., transition from \\(P_{A0}\\) to \\(P_{AA}\\)). After plants within the state \\(P_{AA}\\) die, a site with microbial legacy is left behind, denoted as \\(P_{0A}\\). These empty sites can be recolonized (i.e., transition from \\(P_{0A}\\) back to \\(P_{AA}\\)) with rates affected by the microbial legacy effect, \\(\\alpha\\). Finally, the microbial community within the soil may decay to unconditioned state with rate \\(d_{A}\\), transitioning the state from \\(P_{0A}\\) to \\(P_{00}\\). In this lab, we are going to model the dynamics of this plant-soil system. We will start by converting the flow diagram into a set of differential equations and then solve them numerically using the package deSolve. library(deSolve) library(ggplot2) library(tidyr) ### Model specification PSF &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dP00_dt = P0A*dA + PA0*mA - P00*(PA0 + PAA)*rA dPA0_dt = P00*(PA0 + PAA)*rA - PA0*mA - PA0*cA dPAA_dt = PA0*cA - PAA*mA + P0A*(PA0 + PAA)*rA*alpha dP0A_dt = PAA*mA - P0A*(PA0 + PAA)*rA*alpha - P0A*dA return(list(c(dP00_dt, dPA0_dt, dPAA_dt, dP0A_dt))) }) } ### Model parameters times &lt;- seq(0, 20, by = 0.1) state &lt;- c(P00 = 0.25, PA0 = 0.25, PAA = 0.25, P0A = 0.25) parms &lt;- c(rA = 0.5, mA = 0.1, cA = 0.5, dA = 0.4, alpha = 0.7) ### ODE solver pop_size &lt;- ode(func = PSF, times = times, y = state, parms = parms) # take a look at the results head(pop_size) ## time P00 PA0 PAA P0A ## [1,] 0.0 0.2500000 0.2500000 0.2500000 0.2500000 ## [2,] 0.1 0.2558649 0.2416153 0.2640144 0.2385055 ## [3,] 0.2 0.2609930 0.2339241 0.2773399 0.2277430 ## [4,] 0.3 0.2654349 0.2268709 0.2900255 0.2176687 ## [5,] 0.4 0.2692386 0.2204039 0.3021162 0.2082413 ## [6,] 0.5 0.2724484 0.2144756 0.3136533 0.1994227 tail(pop_size) ## time P00 PA0 PAA P0A ## [196,] 19.5 0.1283001 0.08252532 0.6866677 0.1025070 ## [197,] 19.6 0.1282914 0.08250852 0.6866865 0.1025136 ## [198,] 19.7 0.1282832 0.08249240 0.6867045 0.1025199 ## [199,] 19.8 0.1282754 0.08247693 0.6867217 0.1025260 ## [200,] 19.9 0.1282679 0.08246208 0.6867382 0.1025319 ## [201,] 20.0 0.1282608 0.08244784 0.6867539 0.1025375 ### Visualization I pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;patch&quot;, value = &quot;proportion&quot;, -time) %&gt;% ggplot(aes(x = time, y = proportion, color = patch)) + geom_line(size = 1.5) ### Visualization II plot(range(times), c(0,1), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;proportion&quot;) lines(P00 ~ time, data = pop_size, col = &quot;tomato&quot;) lines(P0A ~ time, data = pop_size, col = &quot;navy&quot;) lines(PA0 ~ time, data = pop_size, col = &quot;gray&quot;) lines(PAA ~ time, data = pop_size, col = &quot;orange&quot;) legend(&quot;topleft&quot;, legend = c(&quot;P00&quot;, &quot;P0A&quot;, &quot;PA0&quot;, &quot;PAA&quot;), col = c(&quot;tomato&quot;, &quot;navy&quot;, &quot;gray&quot;, &quot;orange&quot;), lty = 1) "],["week-7---lotka-volterra-competition-model---population-dynamics.html", "Week 7 - Lotka-Volterra competition model - Population dynamics", " Week 7 - Lotka-Volterra competition model - Population dynamics In this lab, we are going to analyze the two-species Lotka-Volterra competition model numerically and visualize the population dynamics under different parameter settings. library(ggplot2) library(tidyverse) library(deSolve) LV_model &lt;- function(r1 = 1.4, r2 = 1.2, a11 = 1/200, a21 = 1/400, a22 = 1/200, a12 = 1/300, N1_0 = 10, N2_0 = 10) { ### Model specification LV &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = N1 * (r1 - a11*N1 - a12*N2) dN2_dt = N2 * (r2 - a22*N2 - a21*N1) return(list(c(dN1_dt, dN2_dt))) }) } ### Model parameters times &lt;- seq(0, 100, by = 0.1) state &lt;- c(N1 = N1_0, N2 = N2_0) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) ### Model application pop_size &lt;- ode(func = LV, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;pop_size&quot;, -time) %&gt;% ggplot(aes(x = time, y = pop_size, color = Species)) + geom_line(size = 1.5) } ### Different parameter settings ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/100, a12 = 1/200, N1_0 = 200, N2_0 = 5) # N1 wins ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/100, a12 = 1/200, N1_0 = 10, N2_0 = 200) # N1 wins ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/200, a12 = 1/100, N1_0 = 200, N2_0 = 5) # N2 wins ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/200, a12 = 1/100, N1_0 = 5, N2_0 = 200) # N2 wins ## N1_0 = 200 and N2_0 = 5 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/300, N1_0 = 200, N2_0 = 5) # stable coexistence ## N1_0 = 5 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/300, N1_0 = 5, N2_0 = 200) # stable coexistence ## N1_0 = 200 and N2_0 = 150 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, N1_0 = 200, N2_0 = 150) # priority effect (N1 wins) ## N1_0 = 150 and N2_0 = 200 LV_model(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, N1_0 = 150, N2_0 = 200) # priority effect (N2 wins) #### phase diagram phase_plane &lt;- function(r1, r2, a11, a21, a22, a12, title, t){ ### Vectors LV &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = N1 * (r1 - a11*N1 - a12*N2) dN2_dt = N2 * (r2 - a22*N2 - a21*N1) return(list(c(dN1_dt, dN2_dt))) }) } times &lt;- c(0, t) parms &lt;- c(r1 = r1, r2 = r2, a11 = a11, a21 = a21, a22 = a22, a12 = a12) x_inter&lt;- max(c(r1/a11, r2/a21)) y_inter &lt;- max(c(r2/a22, r1/a12)) # create position of arrows vector_grid &lt;- expand.grid(seq(5, x_inter, length.out = 10), seq(5, y_inter, length.out = 10)) vector_data &lt;- vector_grid %&gt;% pmap(., function(Var1, Var2){ state &lt;- c(N1 = Var1, N2 = Var2) pop_size &lt;- ode(func = LV, times = times, y = state, parms = parms) pop_size[2, 2:3] }) %&gt;% bind_rows() %&gt;% rename(xend = N1, yend = N2) %&gt;% bind_cols(vector_grid) %&gt;% rename(x = Var1, y = Var2) ### Phase plane ggplot() + geom_abline(slope = -a11/a12, intercept = r1/a12, color = &quot;#E41A1C&quot;, size = 1.5) + geom_abline(slope = -a21/a22, intercept = r2/a22, color = &quot;#377EB8&quot;, size = 1.5) + geom_segment(data = vector_data, aes(x = x, y = y, xend = xend, yend = yend), arrow = arrow(length = unit(0.1, &quot;cm&quot;))) + scale_x_continuous(name = &quot;N1&quot;, limits = c(0, x_inter), expand = c(0, 0)) + scale_y_continuous(name = &quot;N2&quot;, limits = c(0, y_inter), expand = c(0, 0)) + theme_bw(base_size = 13) + theme(panel.grid = element_blank(), plot.title = element_text(hjust = 0.5)) + labs(title = title) } phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/100, a21 = 1/200, a22 = 1/100, a12 = 1/300, t = 0.3, title = &quot;Stable coexistence&quot;) phase_plane(r1 = 1.2, r2 = 1.2, a11 = 1/200, a21 = 1/100, a22 = 1/200, a12 = 1/100, t = 0.3, title = &quot;Unstable coexistence (saddle)&quot;) "],["week-8---midterm.html", "Week 8 - Midterm", " Week 8 - Midterm "],["week-9---lotka-volterra-competition-model---visualization-of-dynamics-with-complex-eigenvalues.html", "Week 9 - Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues", " Week 9 - Lotka-Volterra competition model - Visualization of dynamics with complex eigenvalues Consider a linear system \\[ \\dfrac{d \\vec{\\pmb\\varepsilon}}{d t} = \\mathcal{J}\\vec{\\pmb\\varepsilon} \\] where \\(\\vec{\\pmb\\varepsilon} = (\\varepsilon_1, \\varepsilon_2)^T\\) and \\(\\mathcal{J} = \\begin{pmatrix} -1 &amp; 1\\\\ -2 &amp; -1 \\end{pmatrix}\\). Or, we can write the linear system by two ODEs: \\[\\begin{align*} \\dfrac{d \\varepsilon_1}{d t} &amp;= (-1)\\times \\varepsilon_1 + (1)\\times\\varepsilon_2\\\\ \\dfrac{d \\varepsilon_2}{d t} &amp;= (-2)\\times \\varepsilon_1 + (-1)\\times\\varepsilon_2\\\\ \\end{align*}\\] Note that the element in the first row and second column is positive. ## time e1 e2 ## [99996,] 9.9995 3.192479e-05 -6.443030e-05 ## [99997,] 9.9996 3.191516e-05 -6.443024e-05 ## [99998,] 9.9997 3.190552e-05 -6.443018e-05 ## [99999,] 9.9998 3.189589e-05 -6.443011e-05 ## [100000,] 9.9999 3.188626e-05 -6.443005e-05 ## [100001,] 10.0000 3.187663e-05 -6.442998e-05 "],["week-10---lotka-volterra-model-of-predator-prey-interactions-and-time-scale-separation.html", "Week 10 - Lotka-Volterra model of predator-prey interactions and time-scale separation", " Week 10 - Lotka-Volterra model of predator-prey interactions and time-scale separation Part 1: analyzing the classic Lotka-Volterra predator-prey model In this lab, we are going to analyze the classic Lotka-Volterra predator-prey model: \\[\\begin{align*} \\frac {dN}{dt} &amp;= rN-aNP\\\\ \\frac {dP}{dt} &amp;= eaNP-dP \\end{align*}\\] The non-trivial equilibrium of this system is \\(E_c = (N = \\frac{d}{ea}, P = \\frac{r}{a})\\). We simulate the model using the following parameter set (\\(N_0\\) = 10, \\(P_0\\) = 2, \\(r\\) = 1.0, \\(a\\) = 0.1, \\(e\\) = 0.8, \\(d\\) = 0.5) and plot the population trajectories of predator and prey over time. We also show their population dynamics in the state-space diagram. What will happen if you add a perturbation to the system (i.e., change the initial conditions)? Try out different values of \\(N\\) and \\(P\\) and visualize the differences in the state-space diagram by yourselve. library(deSolve) ### Model specification LV_predation_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N - a*N*P dP_dt = e*a*N*P - d*P return(list(c(dN_dt, dP_dt))) }) } ### Model parameters times &lt;- seq(0, 100, by = 0.01) state &lt;- c(N = 10, P = 2) parms &lt;- c(r = 1.0, a = 0.1, e = 0.8, d = 0.5) ### Model application pop_size &lt;- ode(func = LV_predation_model, times = times, y = state, parms = parms) ### Visualization -- population dynamics plot(c(0, max(times)), c(0, max(pop_size[, c(&quot;N&quot;, &quot;P&quot;)] + 10)), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;population size&quot;) lines(N ~ time, data = pop_size, col = &quot;blue&quot;) # dynamics of N lines(P ~ time, data = pop_size, col = &quot;red&quot;) # dynamics of P abline(h = parms[4]/(parms[3] * parms[2]), col = &quot;blue&quot;, lty = 2) # equilibrium of N abline(h = parms[1] / parms[2], col = &quot;red&quot;, lty = 2) # equilibrium of P legend(&quot;topright&quot;, legend = c(&quot;N&quot;, &quot;P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) ### Visualization -- state-space diagram plot(N ~ P, data = pop_size, type = &quot;l&quot;) points(parms[4]/(parms[3] * parms[2]), parms[1] / parms[2]) # equilibrium What is the relationship between the long-term average of the cycle and the originally-expected equilibrium? To calculate long-term average, we need to find out the period of the cycle and then calculate the average population size within a period. The period of the cycle may be derived from the distance between peaks in the dynamics shown above, or by some algorithms, e.g. pracma::findpeaks. Part 2: Time-scale separation Time-scale separation is a useful technique to reduce the dimension of the model system, where some state variables are assumed to operate at a much shorter time scale (i.e., fast variables) compared with the others (i.e., slow variables). The fast variables will be attracted rapidly to their new equilibrium in response to a slight change in the slow variables, such that the slow variables can be viewed as “constants” from the perspective of fast variables (and the fast variable will always be at its quasi-equilibrium from the perspective of the slow variable). Here, we are going to use the Lotka-Volterra model with logistic prey growth to demonstrate the time-scale separation technique: \\[\\begin{align*} \\frac {dN}{dt} &amp;= rN(1-\\frac{N}{K})-aNP\\\\ \\frac {dP}{dt} &amp;= eaNP-dP \\end{align*}\\] The ZNGIs of \\(N\\) are \\(N = 0\\) and \\(r(1-\\frac{N}{K}) - aP = 0\\) and the ZNGIs of \\(P\\) are \\(P = 0\\) and \\(eaN = d\\) in this model. We treat prey as a fast variable and predator as a slow variable. First, we find the quasi-equilibrium \\(\\widehat{N}\\) of prey by setting the prey equation to zero: \\[\\widehat{N} = K(1-\\frac{aP}{r})\\] And then we plug \\(\\widehat{N}\\) into predator equation: \\[\\frac {dP}{dt} = (eaK-d)P(1-\\frac{eaK(\\frac{a}{r})}{eaK-d}P)\\] One simple way to achieve time-scale separation in this model is to increase the prey growth rate so that prey will grow much faster than predator, mimicking the shorter generation time of prey relative to that of predator. library(deSolve) Prey_logistic_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(1-(N/K))-a*N*P dP_dt = e*a*N*P-d*P return(list(c(dN_dt, dP_dt))) }) } times &lt;- seq(0, 100, by = 0.01) state &lt;- c(N = 40, P = 20) parms &lt;- c(r = 40, K = 60, a = 0.1, e = 0.1, d = 0.5) # r is chosen to be sufficiently large for time-scale separation pop_size &lt;- ode(func = Prey_logistic_model, times = times, y = state, parms = parms) Under time-scale separation, population of prey rapidly becomes stable and predator exhibits a logistic growth. We show these by the trajectories of \\(P\\) and \\(N\\) over time. # population trajectories plot(c(0, max(times)), c(0, max(pop_size[, c(&quot;N&quot;, &quot;P&quot;)] + 10)), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;population size&quot;) lines(N ~ time, data = pop_size, col = &quot;blue&quot;) # dynamics of N lines(P ~ time, data = pop_size, col = &quot;red&quot;) # dynamics of P legend(&quot;topright&quot;, legend = c(&quot;N&quot;, &quot;P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) Since \\(N\\) is a fast variable, it will immediately achieve the its ZNGI on the state-space diagram. # state-space diagram plot(c(0, max(pop_size[, &quot;N&quot;])), c(0, max(pop_size[, &quot;P&quot;])), type = &quot;n&quot;, xlab = &quot;N&quot;, ylab = &quot;P&quot;) abline(v = 0, col = &quot;blue&quot;) # ZNGI of N abline(a = parms[1]/parms[3], b = -parms[1]/(parms[3]*parms[2]), col = &quot;blue&quot;) # ZNGI of N abline(h = 0, col = &quot;red&quot;) # ZNGI of P abline(v = parms[5]/(parms[4]*parms[3]), col = &quot;red&quot;) # ZNGI of P points(P ~ N, data = pop_size, col = &quot;gray&quot;) Play with the growth rate \\(r\\) from small to large values and see how the trajectory of prey and predator moves along the state-space. Shiny app is credit to Gen-Chang Hsu "],["week-11---no-class-due-to-ntu-anniversary.html", "Week 11 - No class due to NTU anniversary", " Week 11 - No class due to NTU anniversary "],["week-12---rosenzweig-macarthur-predator-prey-model-and-mays-complexity-stability-relationship.html", "Week 12 - Rosenzweig-MacArthur predator-prey model and May’s complexity-stability relationship", " Week 12 - Rosenzweig-MacArthur predator-prey model and May’s complexity-stability relationship Part 1: Rosenzweig–MacArthur predator–prey model In this lab we are going to analyze the Rosenzweig–MacArthur predator–prey model: \\[\\begin{align*} \\frac {dN}{dt} &amp;= rN(1-\\frac{N}{K})-a\\frac{N}{1+ahN}P\\\\ \\frac {dP}{dt} &amp;= ea\\frac{N}{1+ahN}P-dP,\\\\ \\end{align*}\\] where \\(r\\) is the intrinsic growth rate of prey, \\(K\\) is the carrying capacity of prey, \\(a\\) is the rate of prey being consumed by predator, \\(h\\) is the handling time of predator, \\(e\\) is the assimilation rate of predation and \\(d\\) is the mortality rate of predator. The ZNGIs of \\(N\\) are \\[ N = 0 \\text{ and } P = \\frac{r}{a}(1-\\frac{N}{K})(1+ahN) \\] and the ZNGIs of \\(P\\) are \\[ P = 0 \\text{ and } N = \\frac{d}{a(e-dh)} \\] The coexistence equilibrium is \\(E_{np} = \\left(N^* = \\frac{d}{a(e-dh)}, P^* = \\frac{r}{a}(1-\\frac{N^*}{K})(1+ahN^*)\\right)\\). Please simulate the model using the parameter set (\\(N_0\\) = 5, \\(P_0\\) = 2, \\(r\\) = 1.0, \\(K\\) = 5.0, \\(a\\) = 1.3, \\(h\\) = 0.9, \\(e\\) = 0.6, \\(d\\) = 0.5) and plot the population trajectories of predator and prey as well as show their population dynamics in the state-space diagram. library(deSolve) ### Model specification RM_predation_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN_dt = r*N*(1-(N/K))-(a*N/(1+a*h*N))*P dP_dt = e*(a*N/(1+a*h*N))*P-d*P return(list(c(dN_dt, dP_dt))) }) } ### Model parameters times &lt;- seq(0, 200, by = 0.01) state &lt;- c(N = 5, P = 2) parms &lt;- c(r = 1.0, K = 5.0, a = 1.3, h = 0.9, e = 0.6, d = 0.5) ### Model application pop_size &lt;- ode(func = RM_predation_model, times = times, y = state, parms = parms) ### equilibrium E_np &lt;- with(as.list(parms), c(N = d/(a*(e-d*h)), P = r/a*(1-d/(a*(e-d*h))/K)*(1+a*h*d/(a*(e-d*h))))) ### Visualize the population dynamics # population trajectories plot(c(0, max(times)), c(0, max(pop_size[, c(&quot;N&quot;, &quot;P&quot;)])), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;population size&quot;) lines(N ~ time, data = pop_size, col = &quot;blue&quot;) # dynamics of N lines(P ~ time, data = pop_size, col = &quot;red&quot;) # dynamics of P legend(&quot;topright&quot;, legend = c(&quot;N&quot;, &quot;P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) # state-space diagram max_P &lt;- max(pop_size[ ,&quot;P&quot;]) max_N &lt;- max(pop_size[ ,&quot;N&quot;]) plot(P ~ N, data = pop_size, type = &quot;l&quot;, xlim = c(0, max_N*1.2), ylim = c(0, max_P*1.2)) points(E_np[&quot;P&quot;] ~ E_np[&quot;N&quot;], pch = 16) # equilibrium with(as.list(parms), { # ZNGIs of N abline(v = 0, col = &quot;blue&quot;) curve(r/a*(1-x/K)*(1+a*h*x), from = -2, to = K+2, col = &quot;blue&quot;, add = T) # ZNGIs of P abline(h = 0, col = &quot;red&quot;) abline(v = d/(a*(e-d*h)), col = &quot;red&quot;) }) legend(&quot;topright&quot;, legend = c(&quot;ZNGIs of N&quot;, &quot;ZNGIs of P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) Remark: with() is a function that you can load the value in the object without subsetting. Now we increase the carry capacity \\(K\\) to show the paradox of enrichment. Let’s consider \\(K = 7\\) with other parameters fixed. ### Model parameters times &lt;- seq(0, 200, by = 0.01) state &lt;- c(N = 5, P = 2) parms &lt;- c(r = 1.0, K = 7.0, a = 1.3, h = 0.9, e = 0.6, d = 0.5) ### Model application pop_size &lt;- ode(func = RM_predation_model, times = times, y = state, parms = parms) ### equilibrium E_np &lt;- with(as.list(parms), c(N = d/(a*(e-d*h)), P = r/a*(1-d/(a*(e-d*h))/K)*(1+a*h*d/(a*(e-d*h))))) The population size of \\(N\\) and \\(P\\) do not stay at the equilibrium but cycle. ### Visualize the population dynamics # population trajectories plot(c(0, max(times)), c(0, max(pop_size[, c(&quot;N&quot;, &quot;P&quot;)])*1.2), type = &quot;n&quot;, xlab = &quot;time&quot;, ylab = &quot;population size&quot;) lines(N ~ time, data = pop_size, col = &quot;blue&quot;) # dynamics of N lines(P ~ time, data = pop_size, col = &quot;red&quot;) # dynamics of P legend(&quot;topright&quot;, legend = c(&quot;N&quot;, &quot;P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) # state-space diagram max_P &lt;- max(pop_size[ ,&quot;P&quot;]) max_N &lt;- max(pop_size[ ,&quot;N&quot;]) plot(P ~ N, data = pop_size, type = &quot;l&quot;, xlim = c(0, max_N*1.2), ylim = c(0, max_P*1.2)) points(E_np[&quot;P&quot;] ~ E_np[&quot;N&quot;], pch = 16) # equilibrium with(as.list(parms), { # ZNGIs of N abline(v = 0, col = &quot;blue&quot;) curve(r/a*(1-x/K)*(1+a*h*x), from = -2, to = K+2, col = &quot;blue&quot;, add = T) # ZNGIs of P abline(h = 0, col = &quot;red&quot;) abline(v = d/(a*(e-d*h)), col = &quot;red&quot;) }) legend(&quot;topright&quot;, legend = c(&quot;ZNGIs of N&quot;, &quot;ZNGIs of P&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) Do the long-term average of the population size equal to the equilibrium? Let’s calculate the long-term average of population size by function pracma::findpeaks(). It returns a matrix where each row represents one peak found. The first column gives the height, the second the position/index where the maximum is reached, the third and forth the indices of where the peak begins and ends — in the sense of where the pattern starts and ends. library(pracma) # find time points when local peaks occur peaks &lt;- findpeaks(pop_size[, &quot;N&quot;])[ ,2] peaks ## [1] 2219 5694 8960 12225 15490 18755 # get period as time between peaks periods &lt;- peaks[length(peaks)] - peaks[length(peaks) - 1] # long-term average of N avg_N &lt;- mean(pop_size[(length(times) - periods + 1):length(times), &quot;N&quot;]) avg_N ## [1] 3.642661 # long-term average of P avg_P &lt;- mean(pop_size[(length(times) - periods + 1):length(times), &quot;P&quot;]) avg_P ## [1] 1.4757 # equilibrium of N and P E_np ## N P ## 2.564103 1.949845 We show that the the long-term average of the population size of \\(N\\) and \\(P\\) are not identical to the equilibrium of \\(N\\) and \\(P\\). In fact, the long-term average of the resource \\(N\\) is larger than the original equilibrium due to the fact that the per capita growth rate of the \\(P\\) is a concave-downward function. What will happen if you add a perturbation to the system (i.e., change the initial conditions)? Try out different values of \\(N_0\\) and \\(P_0\\) and visualize the differences in the state-space diagram. Shiny app is credit to Gen-Chang Hsu Part 2: May’s complexity-stability relationship May’s insight was to skip the Jacobian calculation altogether and directly consider the Jacobian matrix as a large random matrix (\\(\\mathbf{M}\\), with elements \\(m_{ij}\\)) resting at a feasible equilibrium, and then the eigenvalues of the Jacobian matrix could be derived based on random matrix theory. Let’s try to recreate May’s random matrix. In particular, May considered the following algorithm to build the random Jacobian matrix for \\(S\\) species (thereby a \\(S \\times S\\) matrix): Here, \\(C\\) represents the connectedness of the system (chance of species interacting with each other), \\(\\sigma^{2}\\) can be considered as the realized interaction strengths, and \\(d\\) is the strength of self-limitation. # code for building May&#39;s random matrix BuildMay = function(S, C, d, sigma){ # fill the whole matrix entry &lt;- rnorm(S * S, mean = 0, sd = sigma) M &lt;- matrix(entry, nrow = S, ncol = S) # remove connections remove &lt;- matrix(runif(S * S) &lt;= C, nrow = S, ncol = S) M &lt;- M * remove sum(M != 0) / (S*S) # should equal to C # substrate diagonal elements by d diag(M) &lt;- diag(M) - d return(M) } May &lt;- BuildMay(S = 500, C = 0.5, d = 10, sigma = 1) EVals &lt;- eigen(May)$values Re.EVals &lt;- Re(EVals) Im.EVals &lt;- Im(EVals) plot(Re.EVals, Im.EVals, xlab = &quot;Real part&quot;, ylab = &quot;Imaginary part&quot;) abline(v = 0, col = &quot;red&quot;, lty = 2) Extra reading: Elliptic raw In May’s random matrix, the entries \\(m_{ij}\\), which represents the effect of species \\(j\\) on species \\(i\\)’s growth rate, are independently generated. However, in ecological networks, we usually model pairwise interaction such as consumer-resource, mutualism, and competition, in which cases, \\(m_{ij}\\) is not independent of \\(m_{ji}\\). For consumer-resources interactions, \\(m_{ij}\\) and \\(m_{ji}\\) are negatively correlated. For mutualism or competition interaction, \\(m_{ij}\\) and \\(m_{ji}\\) are positively correlated. Under the assumption that the pairwise interactions are correlated, we may show that the eigenvalues of the randomly generated Jacobian do not follow uniform distribution in a circle, but in an ellipse. We build a function BuildElliptic with argument \\(S\\) is the number of species (i.e. the dimension of the Jacobian), \\(C\\) is the connectance, \\(d\\) is the strength of self-limitation, \\(\\sigma\\) is the variance (i.e. the realized interaction strength) and \\(\\rho\\) is the correlation of the pairwise interaction. library(ggplot2) #### The function to build Elliptic law BuildElliptic &lt;- function(S, C, d, sigma, rho){ # sample coefficients in pairs pairs &lt;- MASS::mvrnorm(n = S * (S-1) / 2, mu = c(0, 0), Sigma = sigma^2 * matrix(c(1, rho, rho, 1), 2, 2)) # build a completely filled matrix M &lt;- matrix(0, S, S) M[upper.tri(M)] &lt;- pairs[,1] M &lt;- t(M) M[upper.tri(M)] &lt;- pairs[,2] # determine which connections to retain (in pairs) Connections &lt;- (matrix(runif(S * S), S, S) &lt;= C) * 1 Connections[lower.tri(Connections)] &lt;- 0 diag(Connections) &lt;- 0 Connections &lt;- Connections + t(Connections) M &lt;- M * Connections # set diagonals diag(M) &lt;- diag(M) - d return(M) } # consumer-resources interactions M_CR &lt;- BuildElliptic(S = 500, C = 0.3, d = 10, sigma = 1, rho = -0.5) EVals_CR &lt;- eigen(M_CR)$values Re.EVals_CR &lt;- Re(EVals_CR) Im.EVals_CR &lt;- Im(EVals_CR) # mutualism or competition M_MC &lt;- BuildElliptic(S = 500, C = 0.3, d = 10, sigma = 1, rho = 0.5) EVals_MC &lt;- eigen(M_MC)$values Re.EVals_MC &lt;- Re(EVals_MC) Im.EVals_MC &lt;- Im(EVals_MC) # combine data Re.EVals &lt;- c(Re.EVals_CR, Re.EVals_MC) Im.EVals &lt;- c(Im.EVals_CR, Im.EVals_MC) # visualization plot(Re.EVals, Im.EVals, xlab = &quot;Real part&quot;, ylab = &quot;Imaginary part&quot;, type = &quot;n&quot;) points(Re.EVals_CR, Im.EVals_CR, col = &quot;green&quot;) points(Re.EVals_MC, Im.EVals_MC, col = &quot;blue&quot;) abline(v = 0, col = &quot;red&quot;, lty = 2) legend(&quot;topleft&quot;, legend = c(&quot;Resource-consumer&quot;, &quot;Mutualism or Competition&quot;), col = c(&quot;green&quot;, &quot;blue&quot;), pch = 1) "],["week-13---parameter-space-for-apparent-competition-model.html", "Week 13 - Parameter space for apparent competition model", " Week 13 - Parameter space for apparent competition model Here, we are going to visualize the outcomes of apparent competition in the \\(r_1/a_1\\) – \\(r_2/a_2\\) space: \\[\\begin{align*} \\frac{dN_1}{dt} &amp;= r_1N_1(1-\\frac{N_1}{K_1}) - a_1N_1P\\\\ \\frac{dN_2}{dt} &amp;= r_2N_2(1-\\frac{N_2}{K_2}) - a_2N_2P\\\\ \\frac{dP}{dt} &amp;= e_1a_1N_1P + e_2a_2N_2P - mP. \\end{align*}\\] Two prey \\(N_1\\) and \\(N_2\\) grow logistically with intrinsic growth rate \\(r_1\\) and \\(r_2\\) and carrying capacity \\(K_1\\) and \\(K_2\\). Predator \\(P\\) consumes two prey following Holling type I functional response, with \\(a_1\\) and \\(a_2\\) representing the consumption rate of \\(N_1\\) and \\(N_2\\) by predator respectively. After consumption, the assimilation rate are \\(e_1\\) and \\(e_2\\). The death rate of predator is represented by \\(m\\). library(deSolve) library(ggplot2) #### Create a function to evaluate the competition outcome Apparent_logistic_func &lt;- function(r1, r2, other.parameters){ # specify the model Apparent_logistic_model &lt;- function(times, state, parms) { with(as.list(c(state, parms)), { dN1_dt = r1 * N1 * (1 - N1 / K1) - a1 * N1 * P dN2_dt = r2 * N2 * (1 - N2 / K2) - a2 * N2 * P dP_dt = e1 * a1 * N1 * P + e2 * a2 * N2 * P - d * P return(list(c(dN1_dt, dN2_dt, dP_dt))) }) } # model parameters times &lt;- seq(0, 3000, by = 10) state &lt;- c(N1 = 0.1, N2 = 0.1, P = 1) parms &lt;- c(r1 = r1, r2 = r2, other.parameters) # run the ode pop_size &lt;- ode(func = Apparent_logistic_model, times = times, y = state, parms = parms) # return final population size N_final &lt;- nrow(na.omit(pop_size)) # remove NAN&#39;s return(pop_size[N_final, -1]) } #### Set up parameter space of interest Parms &lt;- c(r1 = 0.1, r2 = 0.1, a1 = 0.35, a2 = 0.35, e1 = 0.4, e2 = 0.5, d = 0.8, K1 = 15, K2 = 12) r_min &lt;- 0.1 r_max &lt;- 0.7 n &lt;- 100 r1.vec &lt;- seq(r_min, r_max, length.out = n) r2.vec &lt;- seq(r_min, r_max, length.out = n) #### Create parameter space and saving space comp_out &lt;- expand.grid(r1 = r1.vec, r2 = r2.vec) comp_out &lt;- as.data.frame(cbind(comp_out, matrix(0, nrow = dim(comp_out)[1], ncol = 3))) head(comp_out) ## r1 r2 1 2 3 ## 1 0.1000000 0.1 0 0 0 ## 2 0.1060606 0.1 0 0 0 ## 3 0.1121212 0.1 0 0 0 ## 4 0.1181818 0.1 0 0 0 ## 5 0.1242424 0.1 0 0 0 ## 6 0.1303030 0.1 0 0 0 #### Apply the function across the parameter space start_time &lt;- Sys.time() # starting time for(i in 1:dim(comp_out)[1]){ comp_out[i, 3:5] &lt;- Apparent_logistic_func(r1 = comp_out$r1[i], r2 = comp_out$r2[i], other.parameters = Parms[-c(1:2)]) } end_time &lt;- Sys.time() # ending time end_time - start_time # total time spent ## Time difference of 5.88894 mins #### Determine outcome status comp_out$Outcome &lt;- ifelse (comp_out[, 3] &lt; 1e-4, &quot;N2 win&quot;, ifelse(comp_out[, 4] &lt; 1e-4, &quot;N1 win&quot;, &quot;Coexist&quot;)) #### Visualize the competition outcomes in the grids -- base R x &lt;- comp_out$r1 / Parms[3] y &lt;- comp_out$r2 / Parms[4] z &lt;- as.factor(comp_out$Outcome) # Levels: Coexist N1 win N2 win color &lt;- c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;) plot(x, y, type = &quot;n&quot;, xlab = &quot;r1/a1&quot;, ylab = &quot;r2/a2&quot;) size &lt;- 0.008571429 #0.003/0.35 for(i in 1:length(z)){ rect(x[i] - size, y[i] - size, x[i] + size, y[i] + size, col = color[z[i]], border = color[z[i]]) } abline(a = 0, b = (1 - Parms[7] / (Parms[5] * Parms[3] * Parms[8])), lwd = 4) abline(a = 0, b = (1 - Parms[7] / (Parms[6] * Parms[4] * Parms[9]))^-1,, lwd = 4) text(0.5, 1.5, labels = &quot;N2 wins&quot;) text(1.5, 0.5, labels = &quot;N1 wins&quot;) text(1.5, 1.5, labels = &quot;Coexist&quot;) #### Visualize the competition outcomes in the grids -- ggplot ggplot(comp_out, aes(x = r1/Parms[3], y = r2/Parms[4], z = Outcome, fill = Outcome)) + geom_tile() + geom_abline(intercept = 0, slope = (1 - Parms[7] / (Parms[5] * Parms[3] * Parms[8])), size = 1.5) + geom_abline(intercept = 0, slope = (1 - Parms[7] / (Parms[6] * Parms[4] * Parms[9]))^-1, size = 1.5) + labs(x = expression(r[1]/a[1]), y = expression(r[2]/a[2])) + scale_x_continuous(limits = c(r_min/Parms[3], r_max/Parms[4]), expand = c(0, 0)) + scale_y_continuous(limits = c(r_min/Parms[3], r_max/Parms[4]), expand = c(0, 0)) + scale_fill_brewer(palette = &quot;Set1&quot;) + theme_bw(base_size = 14) + theme(panel.grid = element_blank()) + coord_fixed(ratio = 1) + annotate(geom = &quot;text&quot;, x = 0.5, y = 1.5, label = &quot;bold(bolditalic(N[2])~wins)&quot;, parse = T) + annotate(geom = &quot;text&quot;, x = 1.5, y = 1.5, label = &quot;bold(Coexist)&quot;, parse = T) + annotate(geom = &quot;text&quot;, x = 1.5, y = 0.5, label = &quot;bold(bolditalic(N[1])~wins)&quot;, parse = T) If the parameter space is extended and sliced into more tiny grid, the outcomes will be more complete: "],["week-14---resource-competition.html", "Week 14 - Resource competition", " Week 14 - Resource competition Part 1 - R* rule In this part of the lab section, we are going to analyze the consumer-resource dynamics with two consumers and one resource: \\[\\begin{align*} \\frac {dN_{1}}{dt} &amp;= e_{1}a_{1}RN_{1}-dN_{1}\\\\ \\frac {dN_{2}}{dt} &amp;= e_{2}a_{2}RN_{2}-dN_{2}\\\\ \\frac {dR}{dt} &amp;= d(S_{0}-R)-a_{1}RN_{1}-a_{2}RN_{2}\\\\ \\end{align*}\\] Please simulate the model using the parameter set (\\(N_{1(0)}\\) = 2, \\(N_{2(0)}\\) = 2, \\(R\\) = 0.1, \\(a_1\\) = 0.4, \\(a_2\\) = 0.6, \\(e_1\\) = 1, \\(e_2\\) = 1, \\(d\\) = 0.01, \\(S_0\\) = 0.1) and visualize the population trajectories of the two consumers as well as the resource. Below is a plot of resource level vs. consumers’ per capita growth rate. What would you predict about the system dynamics? library(tidyverse) library(deSolve) ### Parameters a1 &lt;- 0.4 a2 &lt;- 0.6 e1 &lt;- 1 e2 &lt;- 1 d &lt;- 0.01 S0 &lt;- 0.1 ### Resource level vs. consumers&#39; per capita population growth data.frame(R = seq(0, 0.1, 0.001)) %&gt;% mutate(N1 = e1*a1*R-d, N2 = e2*a2*R-d) %&gt;% gather(key = &quot;Species&quot;, value = &quot;Growth&quot;, N1:N2) %&gt;% ggplot(aes(x = R, y = Growth, color = Species)) + geom_line() + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;) + labs(x = &quot;Resource level&quot;, y = &quot;Per capita growth rate&quot;) + theme_classic(base_size = 14) ### Model specification CR_model_2C_1R &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1*R*N1 - d*N1 dN2_dt = e2*a2*R*N2 - d*N2 dR_dt = d*(S0-R) - a1*R*N1 - a2*R*N2 return(list(c(dN1_dt, dN2_dt, dR_dt))) }) } ### Model parameters times &lt;- seq(0.1, 1000, by = 0.1) state &lt;- c(N1 = 2, N2 = 2, R = 0.1) parms &lt;- c(a1 = 0.4, a2 = 0.6, e1 = 1, e2 = 1, d = 0.01, S0 = 0.1) ### Model application pop_size &lt;- ode(func = CR_model_2C_1R, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;N&quot;, N1:R) %&gt;% mutate(trophic = case_when(Species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = Species)) + geom_line(size = 1.5) + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 5)) + labs(x = &quot;Time&quot;, y = NULL) + scale_color_manual(name = NULL, values = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;)) We can see that \\(N_1\\) goes extinct, as predicted by the R* rule; the remaining consumer \\(N_2\\) and the resource \\(R\\) exhibit stable coexistence. Part 2 - Tilman’s resource ratio hypothesis Now we will extend the model in Part 1. into two consumers and two resources: \\[\\begin{align*} \\frac {dN_{1}}{dt} &amp;= e_{1}a_{1a}R_{a}N_{1}+e_{1}a_{1b}R_{b}N_{1}-dN_{1}\\\\ \\frac {dN_{2}}{dt} &amp;= e_{2}a_{2a}R_{a}N_{2}+e_{2}a_{2b}R_{b}N_{2}-dN_{2}\\\\ \\frac {dR_{a}}{dt} &amp;= d(S_{a}-R_{a})-a_{1a}R_{a}N_{1}-a_{2a}R_{a}N_{2}\\\\ \\frac {dR_{b}}{dt} &amp;= d(S_{b}-R_{b})-a_{1b}R_{b}N_{1}-a_{2b}R_{b}N_{2}\\\\ \\end{align*}\\] Here, the two consumers \\(N_1\\) and \\(N_2\\) compete for two substitutable resources \\(R_1\\) and \\(R_2\\). Under certain conditions, the two consumers are able to coexist: ### Model specification CR_model_2C_2R &lt;- function(time, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1a*Ra*N1 + e1*a1b*Rb*N1 - d*N1 dN2_dt = e2*a2a*Ra*N2 + e2*a2b*Rb*N2 - d*N2 dRa_dt = d*(Sa-Ra) - (a1a*N1*Ra) - (a2a*N2*Ra) dRb_dt = d*(Sb-Rb) - (a1b*N1*Rb) - (a2b*N2*Rb) return(list(c(dN1_dt, dN2_dt, dRa_dt, dRb_dt))) }) } ### Model parameters times &lt;- seq(0.1, 2000, by = 0.01) state &lt;- c(N1 = 0.05, N2 = 0.05, Ra = 0.3, Rb = 0.3) parms &lt;- c(a1a = 0.4, a1b = 0.8, a2a = 0.6, a2b = 0.5, e1 = 1, e2 = 1, d = 0.1, Sa = 0.3, Sb = 0.3) ### Model application pop_size &lt;- ode(func = CR_model_2C_2R, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;N&quot;, N1:Rb) %&gt;% mutate(trophic = case_when(Species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = Species)) + geom_line(size = 1.5) + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 8)) + labs(x = &quot;Time&quot;, y = NULL) + scale_x_continuous(limits = c(0, 2050), expand = c(0, 0)) + scale_y_continuous(limits = c(0, NA), expand = c(0, 0)) + scale_color_manual(name = NULL, values = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;purple&quot;)) The phase diagram also illustrates stable coexistence of the two consumers: ### Parameters a1a &lt;- 0.4 a1b &lt;- 0.8 a2a &lt;- 0.6 a2b &lt;- 0.5 e1 &lt;- 1 e2 &lt;- 1 d &lt;- 0.1 ### Slopes and intercepts of the ZNGI&#39;s ZNGI_slope_N1 &lt;- -a1a/a1b ZNGI_intercept_N1 &lt;- d/(e1*a1b) ZNGI_slope_N2 &lt;- -a2a/a2b ZNGI_intercept_N2 &lt;- d/(e2*a2b) ### Consumption vectors eqilibrium_Ra &lt;- (d/e1)*((a1b-a2b)/(a2a*a1b-a2b*a1a)) eqilibrium_Rb &lt;- (d/e2)*((a1a-a2a)/(a2b*a1a-a2a*a1b)) convec_df &lt;- data.frame(x = c(eqilibrium_Ra + 6*a1a*eqilibrium_Ra, eqilibrium_Ra + 6*a2a*eqilibrium_Ra), y = c(eqilibrium_Rb + 6*a1b*eqilibrium_Rb, eqilibrium_Rb + 6*a2b*eqilibrium_Rb), xend = c(eqilibrium_Ra - a1a*eqilibrium_Ra, eqilibrium_Ra - a2a*eqilibrium_Ra), yend = c(eqilibrium_Rb - a1b*eqilibrium_Rb, eqilibrium_Rb - a2b*eqilibrium_Rb), species = c(&quot;N1&quot;, &quot;N2&quot;)) ### Phase diagram ggplot() + geom_abline(slope = ZNGI_slope_N1, intercept = ZNGI_intercept_N1, color = &quot;#377EB8&quot;, size = 1.2) + geom_abline(slope = ZNGI_slope_N2, intercept = ZNGI_intercept_N2, color = &quot;#E41A1C&quot;, size = 1.2) + geom_segment(data = convec_df, aes(x = x, y = y, xend = xend, yend = yend, color = species), linetype = &quot;blank&quot;) + geom_segment(data = convec_df, aes(x = x, y = y, xend = xend, yend = yend, color = species), size = 0.5, linetype = &quot;dashed&quot;, arrow = arrow(type = &quot;closed&quot;, length = unit(0.1, &quot;inches&quot;)), show.legend = F) + geom_path(data = as.data.frame(pop_size), aes(x = Ra, y = Rb), size = 1.2) + geom_point(data = as.data.frame(pop_size), aes(x = last(Ra), y = last(Rb)), size = 2.5) + theme_classic(base_size = 14) + labs(x = expression(italic(R[a])), y = expression(italic(R[b]))) + scale_x_continuous(limits = c(0, 0.5), expand = c(0, 0)) + scale_y_continuous(limits = c(0, 0.5), expand = c(0, 0)) + scale_color_brewer(name = NULL, palette = &quot;Set1&quot;, direction = -1, guide = guide_legend(override.aes = list( linetype = &quot;solid&quot;, size = 1.2))) + coord_fixed(ratio = 1) In this particular case, if the initial resource levels \\(R_{a(0)}\\) and \\(R_{b(0)}\\) fall within the upper area bounded by the two consumption vectors, then the two species will coexist. Part 3 - Relative nonlinearity We have seen in Part 1. that two species cannot coexist on one resource if the consumers consume it in a linear fashion. What if the consumers consume the resource in a non-linear fashion? Could that generate stable coexistence? In this part of the lab section, we will introduce non-linear (type II) functional response into the consumer-resource model in Part 1. for one of the consumers. We also change the resource equation to logistic growth and allow the two consumers to have different conversion efficiencies and mortality rates: \\[\\begin{align*} \\frac {dN_{1}}{dt} &amp;= e_{1}a_{1}RN_{1}-d_{1}N_{1}\\\\ \\frac {dN_{2}}{dt} &amp;= e_{2}\\frac{a_{2}R}{k_{2}+R}N_{2}-d_{2}N_{2}\\\\ \\frac {dR}{dt} &amp;= rR(1-\\frac{R}{K})-a_{1}RN_{1}-\\frac{a_{2}R}{k_{2}+R}N_{2}\\\\ \\end{align*}\\] ### Model specification CR_model_nonlinear &lt;- function(times, state, parms){ with(as.list(c(state, parms)), { dN1_dt = e1*a1*R*N1 - d1*N1 dN2_dt = e2*(a2*R/(k2+R))*N2 - d2*N2 dR_dt = r*R*(1-(R/K)) - a1*R*N1 - ((a2*R)/(k2+R))*N2 return(list(c(dN1_dt, dN2_dt, dR_dt))) }) } ### Model parameters times &lt;- seq(0, 5000, by = 0.1) state &lt;- c(N1 = 0.3, N2 = 19, R = 106) parms &lt;- c(a1 = 0.003, a2 = 0.5, k2 = 50, e1 = 0.33, e2 = 0.3, d1 = 0.11, d2 = 0.1, r = 0.1, K = 300) ### Model application pop_size &lt;- ode(func = CR_model_nonlinear, times = times, y = state, parms = parms) ### Visualize the population dynamics pop_size %&gt;% as.data.frame() %&gt;% gather(key = &quot;Species&quot;, value = &quot;N&quot;, N1:R) %&gt;% mutate(trophic = case_when(Species %in% c(&quot;N1&quot;, &quot;N2&quot;) ~ &quot;Consumer&quot;, TRUE ~ &quot;Resource&quot;)) %&gt;% ggplot(aes(x = time, y = N, color = Species)) + geom_line() + facet_wrap(~ trophic, ncol = 2, scales = &quot;free_y&quot;, strip.position = &quot;left&quot;) + theme_classic(base_size = 14) + theme(strip.background = element_blank(), strip.placement = &quot;outside&quot;, legend.position = &quot;top&quot;, legend.title = element_blank(), plot.margin = margin(r = 5)) + labs(x = &quot;Time&quot;, y = NULL) + scale_color_manual(name = NULL, values = c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;)) As shown in the figure, the two consumers coexist in a fluctuating manner. In fact, the fluctuating properties generated by the combination of logistically growing resources and different nonlinear functions are critical for the coexistence of \\(n\\) species on \\(k&lt;n\\) resources in certain parameter spaces. "],["week-15---research-applications-modern-coexistence-theory-and-plant-soil-feedback.html", "Week 15 - Research applications: modern coexistence theory and plant-soil feedback", " Week 15 - Research applications: modern coexistence theory and plant-soil feedback "],["week-16---final-exam.html", "Week 16 - Final exam", " Week 16 - Final exam "]]
>>>>>>> parent of 3aac1e5 (0722)
